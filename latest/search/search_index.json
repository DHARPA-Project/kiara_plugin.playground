{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kiara plugin: playground","text":"<p>This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara.</p>"},{"location":"#description","title":"Description","text":"<p>playground</p>"},{"location":"#package-content","title":"Package content","text":""},{"location":"#module_types","title":"module_types","text":"<ul> <li> <p><code>create.cut_point_list</code>: Create a list of nodes that are cut-points.</p> </li> <li> <p><code>get.network_info</code>: Return basic information for the newtork graph created, including number of nodes and edges.</p> </li> <li> <p><code>create.degree_rank_list</code>: Creates an ordered table with the rank and raw score for degree centrality.</p> </li> <li> <p><code>create.betweenness_rank_list</code>: Creates an ordered table with the rank and raw score for betweenness centrality.</p> </li> <li> <p><code>create.eigenvector_rank_list</code>: Creates an ordered table with the rank and raw score for betweenness centrality.</p> </li> <li> <p><code>create.closeness_rank_list</code>: Creates an ordered table with the rank and raw score for closeness centrality.</p> </li> <li> <p><code>compute.modularity_group</code>: Calculate modularity for each node and attach modularity group number to node list as attribute.</p> </li> <li> <p><code>onboard.gml_file</code>: This is a preliminary module for onboarding network data from gml files. It will likely be replaced by more generic onboarding modules when those are ready.</p> </li> <li> <p><code>playground.tm_dash.file_name_metadata</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.map_column</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.table_sample</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.add_column</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.viz_data_query</code>: -- n/a --</p> </li> <li> <p><code>playground.get_lineage_data</code>: Get lineage data to display in visualization.</p> </li> </ul>"},{"location":"#operations","title":"operations","text":"<ul> <li> <p><code>compute.modularity_group</code>: Calculate modularity for each node and attach modularity group number to node list as attribute.</p> </li> <li> <p><code>create.betweenness_rank_list</code>: Creates an ordered table with the rank and raw score for betweenness centrality.</p> </li> <li> <p><code>create.closeness_rank_list</code>: Creates an ordered table with the rank and raw score for closeness centrality.</p> </li> <li> <p><code>create.cut_point_list</code>: Create a list of nodes that are cut-points.</p> </li> <li> <p><code>create.degree_rank_list</code>: Creates an ordered table with the rank and raw score for degree centrality.</p> </li> <li> <p><code>create.eigenvector_rank_list</code>: Creates an ordered table with the rank and raw score for betweenness centrality.</p> </li> <li> <p><code>get.network_info</code>: Return basic information for the newtork graph created, including number of nodes and edges.</p> </li> <li> <p><code>onboard.gml_file</code>: This is a preliminary module for onboarding network data from gml files. It will likely be replaced by more generic onboarding modules when those are ready.</p> </li> <li> <p><code>playground.get_lineage_data</code>: Get lineage data to display in visualization.</p> </li> <li> <p><code>playground.tm_dash.add_column</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.file_name_metadata</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.map_column</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.table_sample</code>: -- n/a --</p> </li> <li> <p><code>playground.tm_dash.viz_data_query</code>: -- n/a --</p> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://DHARPA-Project.github.io/kiara_plugin.playground</li> <li>Code: https://github.com/DHARPA-Project/kiara_plugin.playground</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Package contents</li> <li>Usage</li> <li>Development</li> <li>API reference</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prepare-development-environment","title":"Prepare development environment","text":""},{"location":"development/#using-conda-recommended","title":"Using conda (recommended)","text":"<pre><code>conda create -n playground python=3.9\nconda activate playground\nconda install -c conda-forge mamba   # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below\nmamba install -c conda-forge -c dharpa kiara\nmamba install -c conda-forge -c dharpa kiara_plugin.core_types kiara_plugin.tabular   # optional, adjust which plugin packages you depend on, those two are quite common\n</code></pre>"},{"location":"development/#using-python-venv","title":"Using Python venv","text":"<p>Later, alligator.</p>"},{"location":"development/#check-out-the-source-code","title":"Check out the source code","text":"<p>First, fork the kiara_plugin.playground repository into your personal Github account.</p> <p>Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.playground.git) to clone the repository locally:</p> <pre><code>https://github.com/&lt;YOUR_FORKED_GITHUB_ID&gt;/kiara_plugin.playground\n</code></pre>"},{"location":"development/#install-the-kiara-plugin-package-into-it","title":"Install the kiara plugin package into it","text":"<pre><code>cd kiara_plugin.playground\npip install -e '.[all_dev]'\n</code></pre> <p>Here we use the <code>-e</code> option for the <code>pip install</code> command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used.</p> <p>We also install a few additional requirements  (the <code>[all_dev]</code> part in the command above) that are not strictly necessary for <code>kiara</code> itself, or this package, but help with various development-related tasks.</p>"},{"location":"development/#install-some-pre-commit-check-tooling-optional","title":"Install some pre-commit check tooling (optional)","text":"<p>This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a <code>git commit</code> in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes.</p> <pre><code>pre-commit install\npre-commit install --hook-type commit-msg\n</code></pre> <p>In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/</p>"},{"location":"development/#run-kiara","title":"Run kiara","text":"<p>To check if everything works as expected and you can start adding/changing code in this repository, run any <code>kiara</code> command:</p> <pre><code>kiara operation list -t playground\n</code></pre> <p>If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.</p>"},{"location":"usage/","title":"Usage","text":"<p>TO BE DONE</p>"},{"location":"info/SUMMARY/","title":"SUMMARY","text":"<ul> <li>module_types</li> <li>operations</li> </ul>"},{"location":"info/module_types/","title":"module_types","text":""},{"location":"info/module_types/#kiara_info.module_types.create.cut_point_list","title":"<code>create.cut_point_list</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Create a list of nodes that are cut-points.           \n                          Cut-points are any node in a network whose removal    \n                          disconnects members of the network, creating one or   \n                          more new distinct components.                         \n                          Uses networkx.articulation_points()                   \n                          https://networkx.org/documentation/stable/referenc\u2026   \n                       Author(s)                                                                      \n    Caitlin Burge              caitlin.burge@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    CutPointsList                    \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class CutPointsList(KiaraModule):                     \n \"\"\"Create a list of nodes that are cut-points.    \n     Cut-points are any node in a network whose rem\u2026   \n     Uses networkx.articulation_points()               \n     https://networkx.org/documentation/stable/refe\u2026   \n     _module_type_name = 'create.cut_point_list'       \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_result\": {                       \n \"type\": \"list\",                       \n \"doc\" : \"A list of all nodes that \u2026   \n             },                                        \n \"centrality_network\": {                   \n \"type\": \"network_data\",               \n \"doc\": \"Updated network data with \u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         network_data: NetworkData = edges.data  # \u2026   \n # \u2026   \n # \u2026   \n         G = network_data.as_networkx_graph(nx.Grap\u2026   \n         cutpoints = list(nx.articulation_points(G))   \n         cut_dict = {}                                 \n for node in G:                                \n if node in cutpoints:                     \n                 cut_dict[node] = 'Yes'                \n else:                                     \n                 cut_dict[node] = 'No'                 \n         nx.set_node_attributes(G, cut_dict, 'Cut P\u2026   \n         attribute_network = NetworkData.create_fro\u2026   \n         outputs.set_values(network_result=cutpoint\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.get.network_info","title":"<code>get.network_info</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Return basic information for the newtork graph        \n                          created, including number of nodes and edges.         \n                          Needs to specify if graph is directed or              \n                          undirected, but will default to undirected.           \n                       Author(s)                                                                      \n    Caitlin Burge              caitlin.burge@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    NetworkInfo                      \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class NetworkInfo(KiaraModule):                       \n \"\"\"Return basic information for the newtork gr\u2026   \n     Needs to specify if graph is directed or undir\u2026   \n     _module_type_name = 'get.network_info'            \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n             },                                        \n \"graph_type\": {                           \n \"type\": \"string\",                     \n \"doc\": \"The graph type: directed o\u2026   \n \"default\": \"undirected\"               \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_result\": {                       \n \"type\": \"string\",                     \n \"doc\" : \"Information about the net\u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         graph = inputs.get_value_data('graph_type')   \n         network_data: NetworkData = edges.data  # \u2026   \n # \u2026   \n # \u2026   \n if graph == 'directed':                       \n             G = network_data.as_networkx_graph(nx.\u2026   \n else:                                         \n             G = network_data.as_networkx_graph(nx.\u2026   \n if nx.is_directed(G) == True:                 \n                 info = str(                           \n 'Graph Type: Directed \\n' +           \n 'Number of Nodes: ' + str(nx.numbe\u2026   \n 'Number of Edges: ' + str(nx.numbe\u2026   \n 'Graph Density Score: ' + str(nx.d\u2026   \n 'Number of Connected Components: '\u2026   \n 'Number of nodes in Largest Compon\u2026   \n 'Network Diameter of Largest Compo\u2026   \n 'Average Path Length of Largest Co\u2026   \n                 )                                     \n else:                                         \n             info = str(                               \n 'Graph Type: Undirected \\n' +             \n 'Number of Nodes: ' + str(nx.number_of\u2026   \n 'Number of Edges: ' + str(nx.number_of\u2026   \n 'Graph Density Score: ' + str(nx.densi\u2026   \n 'Number of Connected Components: ' + s\u2026   \n 'Number of nodes in Largest Component:\u2026   \n 'Network Diameter of Largest Component\u2026   \n 'Average Path Length of Largest Compon\u2026   \n                 )                                     \n         outputs.set_value('network_result', info)     \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.degree_rank_list","title":"<code>create.degree_rank_list</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Creates an ordered table with the rank and raw        \n                          score for degree centrality.                          \n                          In an undirected graph, degree centrality measures    \n                          the number of independent connections each node       \n                          has.                                                  \n                          Uses networkx degree.                                 \n                          https://networkx.org/documentation/stable/referenc\u2026   \n                       Author(s)                                                                      \n    Caitlin Burge              caitlin.burge@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    Degree_Ranking                   \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class Degree_Ranking(KiaraModule):                    \n \"\"\"Creates an ordered table with the rank and \u2026   \n     In an undirected graph, degree centrality meas\u2026   \n     Uses networkx degree.                             \n     https://networkx.org/documentation/stable/refe\u2026   \n     _module_type_name = 'create.degree_rank_list'     \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n             },                                        \n \"weighted_degree\":{                       \n \"type\": \"boolean\",                    \n \"default\": True,                      \n \"doc\": \"Boolean to indicate whethe\u2026   \n             },                                        \n \"weight_column_name\": {                   \n \"type\" : \"string\",                    \n \"default\": '',                        \n \"doc\": \"The name of the column in \u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_result\": {                       \n \"type\": \"table\",                      \n \"doc\" : \"A table showing the rank \u2026   \n             },                                        \n \"centrality_network\": {                   \n \"type\": \"network_data\",               \n \"doc\": \"Updated network data with \u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         wd = inputs.get_value_data('weighted_degre\u2026   \n         weight_name = inputs.get_value_data('weigh\u2026   \n         network_data: NetworkData = edges.data  # \u2026   \n # \u2026   \n # \u2026   \n         G = network_data.as_networkx_graph(nx.Grap\u2026   \n         G.remove_edges_from(list(nx.selfloop_edges\u2026   \n def result_func(list):                        \n             rank, count, previous, result = (0, 0,\u2026   \n for key, num in list:                     \n                 count += 1                            \n if num != previous:                   \n                     rank += count                     \n                     previous = num                    \n                     count = 0                         \n                 result[key] = num, rank               \n return result                             \n         degree = {}                                   \n for node in G:                                \n             degree[node]= G.degree(node)              \n         nx.set_node_attributes(G, degree, 'Degree \u2026   \n         sorted_dict = [[item[1][1], item [0], item\u2026   \n         df= pd.DataFrame(sorted_dict, columns=['Ra\u2026   \n if wd == True:                                \n if weight_name == '':                     \n                 MG = network_data.as_networkx_grap\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n                 weight_degree = {}                    \n for node in graph:                    \n                     weight_degree[node]= graph.deg\u2026   \n                 nx.set_node_attributes(G, weight_d\u2026   \n                 df2 = pd.DataFrame(list(weight_deg\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n if weight_name != '':                     \n                 MG = network_data.as_networkx_grap\u2026   \n                 edge_weight = nx.get_edge_attribut\u2026   \n for u,v,key in edge_weight:           \n                     nx.set_edge_attributes(MG, edg\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n                 weight_degree = {}                    \n for node in graph:                    \n                     weight_degree[node]= graph.deg\u2026   \n                 nx.set_node_attributes(G, weight_d\u2026   \n                 df2 = pd.DataFrame(list(weight_deg\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n         attribute_network = NetworkData.create_fro\u2026   \n         outputs.set_values(network_result=df, cent\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.betweenness_rank_list","title":"<code>create.betweenness_rank_list</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Creates an ordered table with the rank and raw        \n                          score for betweenness centrality.                     \n                          In an undirected graph, betweenness centrality        \n                          measures the percentage of all shortest paths that    \n                          a node appears on, therefore measuring the            \n                          likeliness that a node may act as a connector or      \n                          'intermediary'.                                       \n                          Uses networkx.betweenness_centrality()                \n                          https://networkx.org/documentation/stable/referenc\u2026   \n                       Author(s)                                                                      \n    Caitlin Burge              caitlin.burge@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    Betweenness_Ranking              \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class Betweenness_Ranking(KiaraModule):               \n \"\"\"Creates an ordered table with the rank and \u2026   \n     In an undirected graph, betweenness centrality\u2026   \n     Uses networkx.betweenness_centrality()            \n     https://networkx.org/documentation/stable/refe\u2026   \n     _module_type_name = 'create.betweenness_rank_l\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n \"optional\": False,                    \n             },                                        \n \"weighted_betweenness\":{                  \n \"type\": \"boolean\",                    \n \"default\": False,                     \n \"doc\": \"Boolean to indicate whethe\u2026   \n \"optional\": True,                     \n             },                                        \n \"weight_column_name\": {                   \n \"type\" : \"string\",                    \n \"default\": 'weight',                  \n \"doc\": \"The name of the column in \u2026   \n \"optional\": True,                     \n             },                                        \n \"weight_meaning\":{                        \n \"type\": \"boolean\",                    \n \"default\": True,                      \n \"doc\": \"How the weights given shou\u2026   \n \"optional\": True,                     \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_result\": {                       \n \"type\": \"table\",                      \n \"doc\" : \"A table showing the rank \u2026   \n             },                                        \n \"centrality_network\": {                   \n \"type\": \"network_data\",               \n \"doc\": \"Updated network data with \u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         wb = inputs.get_value_data('weighted_betwe\u2026   \n         weight_name = inputs.get_value_data('weigh\u2026   \n         wm = inputs.get_value_data('weight_meaning\u2026   \n         network_data: NetworkData = edges.data  # \u2026   \n # \u2026   \n # \u2026   \n         G = network_data.as_networkx_graph(nx.Grap\u2026   \n         G.remove_edges_from(list(nx.selfloop_edges\u2026   \n         G.remove_nodes_from(list(nx.isolates(G)))     \n def result_func(list):                        \n             rank, count, previous, result = (0, 0,\u2026   \n for key, num in list:                     \n                 count += 1                            \n if num != previous:                   \n                     rank += count                     \n                     previous = num                    \n                     count = 0                         \n                 result[key] = num, rank               \n return result                             \n         between = nx.betweenness_centrality(G)        \n         nx.set_node_attributes(G, between, 'Betwee\u2026   \n         sorted_dict = [[item[1][1], item [0], item\u2026   \n         df= pd.DataFrame(sorted_dict)                 \n         df.columns = ['Rank', 'Node', 'Score']        \n if wb == True:                                \n if weight_name is None:                   \n                 MG = network_data.as_networkx_grap\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n if wm == True:                        \n for u,v,d in graph.edges(data=\u2026   \n                         d['weight']=(1/d['weight'])   \n                 weight_betweenness = nx.betweennes\u2026   \n                 nx.set_node_attributes(G, weight_b\u2026   \n                 df2 = pd.DataFrame(list(weight_bet\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n if weight_name is not None:               \n                 MG = network_data.as_networkx_grap\u2026   \n                 edge_weight = nx.get_edge_attribut\u2026   \n for u,v,key in edge_weight:           \n                     nx.set_edge_attributes(MG, edg\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n if wm == True:                        \n for u,v,d in graph.edges(data=\u2026   \n                         d['weight']=(1/d['weight'])   \n                 weight_betweenness = nx.betweennes\u2026   \n                 nx.set_node_attributes(G, weight_b\u2026   \n                 df2 = pd.DataFrame(list(weight_bet\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n         attribute_network = NetworkData.create_fro\u2026   \n         outputs.set_values(network_result=df, cent\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.eigenvector_rank_list","title":"<code>create.eigenvector_rank_list</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Creates an ordered table with the rank and raw        \n                          score for betweenness centrality.                     \n                          In an undirected graph, eigenvector centrality        \n                          measures the extent to which a node is connected to   \n                          other nodes of importance or influence.               \n                          Uses networkx.eigenvector_centrality()                \n                          https://networkx.org/documentation/stable/referenc\u2026   \n                       Author(s)                                                                      \n    Caitlin Burge              caitlin.burge@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    Eigenvector_Ranking              \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class Eigenvector_Ranking(KiaraModule):               \n \"\"\"Creates an ordered table with the rank and \u2026   \n     In an undirected graph, eigenvector centrality\u2026   \n     Uses networkx.eigenvector_centrality()            \n     https://networkx.org/documentation/stable/refe\u2026   \n     _module_type_name = 'create.eigenvector_rank_l\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n             },                                        \n \"iterations\": {                           \n \"type\" : \"integer\",                   \n \"default\": 1000                       \n             },                                        \n \"weighted_eigenvector\":{                  \n \"type\": \"boolean\",                    \n \"default\": False,                     \n \"doc\": \"Boolean to indicate whethe\u2026   \n             },                                        \n \"weight_column_name\": {                   \n \"type\" : \"string\",                    \n \"default\": '',                        \n \"doc\": \"The name of the column in \u2026   \n             },                                        \n \"weight_meaning\":{                        \n \"type\": \"boolean\",                    \n \"default\": True,                      \n \"doc\": \"How the weights given shou\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_result\": {                       \n \"type\": \"table\",                      \n \"doc\" : \"A table showing the rank \u2026   \n             },                                        \n \"centrality_network\": {                   \n \"type\": \"network_data\",               \n \"doc\": \"Updated network data with \u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         iterations = inputs.get_value_data(\"iterat\u2026   \n         wd = inputs.get_value_data('weighted_eigen\u2026   \n         weight_name = inputs.get_value_data('weigh\u2026   \n         wm = inputs.get_value_data('weight_meaning\u2026   \n         network_data: NetworkData = edges.data  # \u2026   \n # \u2026   \n # \u2026   \n         G = network_data.as_networkx_graph(nx.Grap\u2026   \n         G.remove_edges_from(list(nx.selfloop_edges\u2026   \n def result_func(list):                        \n             rank, count, previous, result = (0, 0,\u2026   \n for key, num in list:                     \n                 count += 1                            \n if num != previous:                   \n                     rank += count                     \n                     previous = num                    \n                     count = 0                         \n                 result[key] = num, rank               \n return result                             \n         eigenvector = nx.eigenvector_centrality(G,\u2026   \n         nx.set_node_attributes(G, eigenvector, 'Ei\u2026   \n         sorted_dict = [[item[1][1], item [0], item\u2026   \n         df= pd.DataFrame(sorted_dict)                 \n         df.columns = ['Rank', 'Node', 'Score']        \n if wd == True:                                \n if weight_name == '':                     \n                 MG = network_data.as_networkx_grap\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n if wm == False:                       \n for u,v,d in graph.edges(data=\u2026   \n                         d['weight'] == 1/d['weight\u2026   \n                 weight_eigenvector = nx.eigenvecto\u2026   \n                 nx.set_node_attributes(G, weight_e\u2026   \n                 df2 = pd.DataFrame(list(weight_eig\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n if weight_name != '':                     \n                 MG = network_data.as_networkx_grap\u2026   \n                 edge_weight = nx.get_edge_attribut\u2026   \n for u,v,key in edge_weight:           \n                     nx.set_edge_attributes(MG, edg\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n if wm == False:                       \n for u,v,d in graph.edges(data=\u2026   \n                         d['weight'] == 1/d['weight\u2026   \n                 weight_eigenvector = nx.eigenvecto\u2026   \n                 nx.set_node_attributes(G, weight_e\u2026   \n                 df2 = pd.DataFrame(list(weight_eig\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n         attribute_network = NetworkData.create_fro\u2026   \n         outputs.set_values(network_result=df, cent\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.create.closeness_rank_list","title":"<code>create.closeness_rank_list</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Creates an ordered table with the rank and raw        \n                          score for closeness centrality.                       \n                          In an undirected graph, closeness centrality          \n                          measures the average shortest distance path between   \n                          a node and all reachable nodes in the network.        \n                          Uses networkx.closeness_centrality()                  \n                          https://networkx.org/documentation/stable/referenc\u2026   \n                       Author(s)                                                                      \n    Caitlin Burge              caitlin.burge@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    Closeness_Ranking                \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class Closeness_Ranking(KiaraModule):                 \n \"\"\"Creates an ordered table with the rank and \u2026   \n     In an undirected graph, closeness centrality m\u2026   \n     Uses networkx.closeness_centrality()              \n     https://networkx.org/documentation/stable/refe\u2026   \n     _module_type_name = 'create.closeness_rank_lis\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network graph being qu\u2026   \n             },                                        \n \"weighted_closeness\":{                    \n \"type\": \"boolean\",                    \n \"default\": False,                     \n \"doc\": \"Boolean to indicate whethe\u2026   \n             },                                        \n \"weight_column_name\": {                   \n \"type\" : \"string\",                    \n \"default\": '',                        \n \"doc\": \"The name of the column in \u2026   \n             },                                        \n \"weight_meaning\":{                        \n \"type\": \"boolean\",                    \n \"default\": True,                      \n \"doc\": \"How the weights given shou\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"network_result\": {                       \n \"type\": \"table\",                      \n \"doc\" : \"A table showing the rank \u2026   \n             },                                        \n \"centrality_network\": {                   \n \"type\": \"network_data\",               \n \"doc\": \"Updated network data with \u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         wd = inputs.get_value_data('weighted_close\u2026   \n         weight_name = inputs.get_value_data('weigh\u2026   \n         wm = inputs.get_value_data('weight_meaning\u2026   \n         network_data: NetworkData = edges.data  # \u2026   \n # \u2026   \n # \u2026   \n         G = network_data.as_networkx_graph(nx.Grap\u2026   \n         G.remove_edges_from(list(nx.selfloop_edges\u2026   \n def result_func(list):                        \n             rank, count, previous, result = (0, 0,\u2026   \n for key, num in list:                     \n                 count += 1                            \n if num != previous:                   \n                     rank += count                     \n                     previous = num                    \n                     count = 0                         \n                 result[key] = num, rank               \n return result                             \n         closeness = nx.closeness_centrality(G)        \n         nx.set_node_attributes(G, closeness, 'Clos\u2026   \n         sorted_dict = [[item[1][1], item [0], item\u2026   \n         df= pd.DataFrame(sorted_dict)                 \n         df.columns = ['Rank', 'Node', 'Score']        \n if wd == True:                                \n if weight_name == '':                     \n                 MG = network_data.as_networkx_grap\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n if wm == True:                        \n for u,v,d in graph.edges(data=\u2026   \n                         d['weight'] == 1/d['weight\u2026   \n                 weight_closeness = nx.closeness_ce\u2026   \n                 nx.set_node_attributes(G, weight_c\u2026   \n                 df2 = pd.DataFrame(list(weight_clo\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n if weight_name != '':                     \n                 MG = network_data.as_networkx_grap\u2026   \n                 edge_weight = nx.get_edge_attribut\u2026   \n for u,v,key in edge_weight:           \n                     nx.set_edge_attributes(MG, edg\u2026   \n                 graph = nx.DiGraph()                  \n for u,v,data in MG.edges(data=True\u2026   \n                     w = data['weight'] if 'weight'\u2026   \n if graph.has_edge(u,v):           \n                         graph[u][v]['weight'] += w    \n else:                             \n                         graph.add_edge(u, v, weigh\u2026   \n if wm == True:                        \n for u,v,d in graph.edges(data=\u2026   \n                         d['weight'] == 1/d['weight\u2026   \n                 weight_closeness = nx.closeness_ce\u2026   \n                 nx.set_node_attributes(G, weight_c\u2026   \n                 df2 = pd.DataFrame(list(weight_clo\u2026   \n                 df = df.merge(df2, how='left', on=\u2026   \n         attribute_network = NetworkData.create_fro\u2026   \n         outputs.set_values(network_result=df, cent\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.compute.modularity_group","title":"<code>compute.modularity_group</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Calculate modularity for each node and attach         \n                          modularity group number to node list as attribute.    \n                          This networkX based function uses                     \n                          Clauset-Newman-Moore greedy modularity maximization   \n                          to find the community partition with the largest      \n                          modularity.                                           \n                          Modularity community is a density-based community     \n                          detection method that investigates the structural     \n                          composition of a network.                             \n                       Author(s)                                                                      \n    Lena Jaskov                helena.jaskov@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    ModularityCommunity              \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class ModularityCommunity(KiaraModule):               \n \"\"\"Calculate modularity for each node and atta\u2026   \n     This networkX based function uses Clauset-Newm\u2026   \n     Modularity community is a density-based commun\u2026   \n     \"\"\"                                               \n     _module_type_name = 'compute.modularity_group'    \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network data to analyz\u2026   \n \"optional\": False,                    \n             },                                        \n \"number_of_communities\":{                 \n \"type\": \"integer\",                    \n \"doc\": \"Number of communities into\u2026   \n \"optional\": True,                     \n             }                                         \n         }                                             \n return result                                 \n def create_outputs_schema(self):                  \n return {                                      \n \"modularity_network\": {                   \n \"type\": \"network_data\",               \n \"doc\": \"Updated network data with \u2026   \n             },                                        \n \"maximum_modularity\":{                    \n \"type\": \"integer\",                    \n \"doc\": \"The number of communities \u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         edges = inputs.get_value_obj('network_data\u2026   \n         network_data: NetworkData = edges.data        \n         G = network_data.as_networkx_graph(nx.Grap\u2026   \n         number_of_communities = inputs.get_value_d\u2026   \n if number_of_communities is None:             \n             communities = community.greedy_modular\u2026   \n             maximum_modularity = len(communities)     \n else:                                         \n             communities = community.greedy_modular\u2026   \n             max_communities = community.greedy_mod\u2026   \n             maximum_modularity = len(max_communiti\u2026   \n         modularity_dict = {}                          \n for i,c in enumerate(communities): # Loop \u2026   \n for name in c: # Loop through each nod\u2026   \n                 modularity_dict[name] = i # Create\u2026   \n         nx.set_node_attributes(G, modularity_dict,\u2026   \n         attribute_network = NetworkData.create_fro\u2026   \n         outputs.set_values(modularity_network=attr\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.onboard.gml_file","title":"<code>onboard.gml_file</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    This is a preliminary module for onboarding network   \n                          data from gml files. It will likely be replaced by    \n                          more generic onboarding modules when those are        \n                          ready.                                                \n                          Based on networkX deserialise GML file method:        \n                          https://networkx.org/documentation/stable/referenc\u2026   \n                       Author(s)                                                                      \n    Lena Jaskov                helena.jaskov@uni.lu       \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    GmlOnboarding                    \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class GmlOnboarding(KiaraModule):                     \n \"\"\"This is a preliminary module for onboarding\u2026   \n     Based on networkX deserialise GML file method:\u2026   \n     \"\"\"                                               \n     _module_type_name = 'onboard.gml_file'            \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n #\"file\": {                                \n #   \"type\": \"file\",                      \n #  \"doc\": \"The source value (of type\u2026   \n # \"optional\": False,                   \n #},                                       \n \"path\": {                                 \n \"type\": \"string\",                     \n \"doc\": \"The path to the local file\u2026   \n \"optional\": False,                    \n             },                                        \n \"label\":{                                 \n \"type\": \"string\",                     \n \"doc\": \"The node attribute that ho\u2026   \n \"optional\": True,                     \n \"default\": \"label\",                   \n             }                                         \n         }                                             \n return result                                 \n def create_outputs_schema(self):                  \n return {                                      \n \"network_data\": {                         \n \"type\": \"network_data\",               \n \"doc\": \"The network/graph data.\"      \n             }                                         \n         }                                             \n def process(self, inputs, outputs):               \n         input_file = inputs.get_value_data('path')    \n         gml_file= input_file                          \n #print(gml_file)                              \n         label = inputs.get_value_data('label')        \n #print(label)                                 \n if label is None:                             \n             G = nx.read_gml(gml_file)                 \n #print(\"no label\")                        \n else:                                         \n             G = nx.read_gml(gml_file, label=label)    \n #print(\"with label\")                      \n         network_data = NetworkData.create_from_net\u2026   \n         outputs.set_values(network_data=network_da\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.playground.tm_dash.file_name_metadata","title":"<code>playground.tm_dash.file_name_metadata</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    FileNameMetadata                 \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class FileNameMetadata(KiaraModule):                  \n     _module_type_name = \"playground.tm_dash.file_n\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"table_input\": {                          \n \"type\": \"table\",                      \n \"doc\": \"The corpus for which we wa\u2026   \n             },                                        \n \"column_name\": {                          \n \"type\": \"string\",                     \n \"doc\": \"The column containing meta\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"table_output\": {                         \n \"type\": \"table\",                      \n \"doc\": \"Augmented table containing\u2026   \n             },                                        \n \"publications_ref\": {                     \n \"type\": \"list\",                       \n \"doc\": \"List of unique publication\u2026   \n              },                                       \n # \"publications_count\": {                 \n #     \"type\": \"list\",                     \n #     \"doc\": \"Count of unique publicat\u2026   \n # }                                       \n         }                                             \n def process(self, inputs, outputs) -&gt; None:       \n         table_obj = inputs.get_value_obj(\"table_in\u2026   \n         column_name = inputs.get_value_obj(\"column\u2026   \n         df = table_obj.data.to_pandas()               \n # get publication ref from file name         \n def get_ref(file):                            \n             ref_match = re.findall(r'(\\w+\\d+)_\\d{4\u2026   \n if not ref_match:                         \n raise KiaraProcessingException(f\"C\u2026   \n return ref_match[0]                       \n # get date from file name                     \n def get_date(file):                           \n             date_match = re.findall(r'_(\\d{4}-\\d{2\u2026   \n if not date_match:                        \n raise KiaraProcessingException(f\"C\u2026   \n return date_match[0]                      \n         df['date'] = df['file_name'].apply(lambda \u2026   \n         df['publication'] = df[column_name].apply(\u2026   \n         df['date'] = pd.to_datetime(df['date'])       \n         df = df.sort_values(by='date')                \n         publications = df['publication'].unique().\u2026   \n # counts = [df['publication'].value_counts\u2026   \n         outputs.set_value(\"table_output\", df)         \n # unique publications references useful at\u2026   \n         outputs.set_value(\"publications_ref\", publ\u2026   \n # outputs.set_value(\"publications_count\", \u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.playground.tm_dash.map_column","title":"<code>playground.tm_dash.map_column</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    MapColumn                        \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class MapColumn(KiaraModule):                         \n     _module_type_name = \"playground.tm_dash.map_co\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"table_input\": {                          \n \"type\": \"table\",                      \n \"doc\": \"The table that we need to \u2026   \n             },                                        \n \"column_name\": {                          \n \"type\": \"string\",                     \n \"doc\": \"The column that needs mapp\u2026   \n             },                                        \n \"mapping_keys\": {                         \n \"type\": \"list\",                       \n \"doc\": \"list containing 2 lists: 1\u2026   \n             },                                        \n \"output_col_name\": {                      \n \"type\": \"string\",                     \n \"doc\": \"name of the newly created \u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"table_output\": {                         \n \"type\": \"table\",                      \n \"doc\": \"Augmented table containing\u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs) -&gt; None:       \n         table_obj = inputs.get_value_obj(\"table_in\u2026   \n         column_name = inputs.get_value_obj(\"column\u2026   \n         mapping_keys = inputs.get_value_obj(\"mappi\u2026   \n         output_col_name = inputs.get_value_obj(\"ou\u2026   \n         df = table_obj.data.to_pandas()               \n         df[output_col_name] = df[column_name].repl\u2026   \n         outputs.set_value(\"table_output\", df)         \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.playground.tm_dash.table_sample","title":"<code>playground.tm_dash.table_sample</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    TableSample                      \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class TableSample(KiaraModule):                       \n     _module_type_name = \"playground.tm_dash.table_\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"table_input\": {                          \n \"type\": \"table\",                      \n \"doc\": \"The table for which we nee\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"table_sample\": {                         \n \"type\": \"table\",                      \n \"doc\": \"Random sample of 15 rows f\u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs) -&gt; None:       \n         table_obj = inputs.get_value_obj(\"table_in\u2026   \n         df = table_obj.data.to_pandas()               \n         df_sample = df.sample(n=15,axis=0)            \n if '__index_level_0__' in df_sample.column\u2026   \n             df_sample = df_sample.drop(['__index_l\u2026   \n         table_pa = pa.Table.from_pandas(df_sample)    \n         outputs.set_value(\"table_sample\", table_pa)   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.playground.tm_dash.add_column","title":"<code>playground.tm_dash.add_column</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    AddColumn                        \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class AddColumn(KiaraModule):                         \n     _module_type_name = \"playground.tm_dash.add_co\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"table_input\": {                          \n \"type\": \"table\",                      \n \"doc\": \"The table to which we need\u2026   \n             },                                        \n \"array_input\": {                          \n \"type\": \"array\",                      \n \"doc\": \"The array that needs to be\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"preprocessed_tokens\": {                  \n \"type\": \"table\",                      \n \"doc\": \"The table with the additio\u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs) -&gt; None:       \n         table_obj = inputs.get_value_obj(\"table_in\u2026   \n         array_obj = inputs.get_value_obj(\"array_in\u2026   \n         df = table_obj.data.to_pandas()               \n         col = array_obj.data.to_pylist()              \n         df['preprocessed_tokens'] = col               \n         outputs.set_value(\"preprocessed_tokens\", d\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.playground.tm_dash.viz_data_query","title":"<code>playground.tm_dash.viz_data_query</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                             \n                       Author(s)                                                                      \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    VizDataQuery                     \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class VizDataQuery(KiaraModule):                      \n     _module_type_name = \"playground.tm_dash.viz_da\u2026   \n def create_inputs_schema(self):                   \n return {                                      \n \"query_type\": {                           \n \"type\": \"string\",                     \n \"doc\": \"The wished data periodicit\u2026   \n             },                                        \n \"column\": {                               \n \"type\": \"string\",                     \n \"doc\": \"The column that contains p\u2026   \n             }                                         \n         }                                             \n def create_outputs_schema(self):                  \n return {                                      \n \"query\": {                                \n \"type\": \"string\",                     \n \"doc\": \"The query to pass to the s\u2026   \n             }                                         \n         }                                             \n def process(self, inputs, outputs) -&gt; None:       \n         agg = inputs.get_value_obj(\"query_type\").d\u2026   \n         col = inputs.get_value_obj(\"column\").data     \n if agg == 'month':                            \n             query = f\"SELECT strptime(concat(month\u2026   \n elif agg == 'year':                           \n             query = f\"SELECT strptime(year, '%Y') \u2026   \n elif agg == 'day':                            \n             query = f\"SELECT strptime(concat('01/'\u2026   \n         outputs.set_value(\"query\", query)             \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.playground.get_lineage_data","title":"<code>playground.get_lineage_data</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Get lineage data to display in visualization.         \n                       Author(s)                                                                      \n    Mariella De Crouy Chanel   mariella.decrouychanel@\u2026   \n Context                                                                        \n  Tags         playground                               \n                        Labels       package: kiara_plugin.playground         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type     Descript\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constants   object   Value       no                   \n                                               constants                        \n                                               for this                         \n                                               module.                          \n                          defaults    object   Value       no                   \n                                               defaults                         \n                                               for this                         \n                                               module.                          \n                       Python class                                                                   \n  python_class_name    GetLineageData                   \n                        python_module_name   kiara_plugin.playground.modul\u2026   \n                        full_name            kiara_plugin.playground.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class GetLineageData(KiaraModule):                    \n \"\"\" Get lineage data to display in visualizati\u2026   \n     \"\"\"                                               \n     _module_type_name = \"playground.get_lineage_da\u2026   \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         inputs = {                                    \n \"table\": {\"type\": \"table\", \"doc\": \"The\u2026   \n         }                                             \n return inputs                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         outputs = {                                   \n \"lineage_dict\": {                         \n \"type\": \"dict\",                       \n \"doc\": \"The dict containing lineag\u2026   \n             }                                         \n         }                                             \n return outputs                                \n def process(self, inputs: ValueMap, outputs: V\u2026   \n         table_obj = inputs.get_value_obj(\"table\")     \n         kiara = KiaraAPI.instance()                   \n         graph = table_obj.lineage.module_graph        \n         nodes = graph.nodes.data()                    \n         augmented_nodes = dict()                      \n def get_info(node):                           \n # all this is terribly inefficient        \n if node[1][\"node_type\"] == \"operation\":   \n                 result = kiara.retrieve_module_typ\u2026   \n elif node[1][\"node_type\"] == \"value\":     \n                 value_id = node[0][6:]                \n                 v = kiara.get_value(value_id)         \n                 render_result = kiara.render_value\u2026   \n                 result = {                            \n \"preview\": render_result          \n                 }                                     \n return result                             \n for idx, node in enumerate(nodes):            \n             node_dict = {                             \n \"id\": node[0],                        \n \"desc\": node[1],                      \n \"parentIds\": [pred for pred in gra\u2026   \n \"info\": get_info(node)                \n             }                                         \n             augmented_nodes[idx] = node_dict          \n         outputs.set_value(\"lineage_dict\", augmente\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/operations/","title":"operations","text":""},{"location":"info/operations/#kiara_info.operations.compute.modularity_group","title":"<code>compute.modularity_group</code>","text":"Documentation <p>Calculate modularity for each node and attach modularity group number to node list as attribute.</p> <p>This networkX based function uses Clauset-Newman-Moore greedy modularity maximization to find the community partition with the largest modularity.</p> <p>Modularity community is a density-based community detection method that investigates the structural composition of a network.</p> Inputs field name type description required default network_data network_data The network data to analyze. yes number_of_communities integer Number of communities into which the network should be partitioned. This is a user defined number that can be above or below maximum modularity. no Outputs field name type description required default modularity_network network_data Updated network data with modularity group assigned as a node attribute. yes maximum_modularity integer The number of communities at which maximum modularity is reached for this network. If the 'number_of_communities' is manually set, this number might deviate from the manually computed number. yes"},{"location":"info/operations/#kiara_info.operations.create.betweenness_rank_list","title":"<code>create.betweenness_rank_list</code>","text":"Documentation <p>Creates an ordered table with the rank and raw score for betweenness centrality.</p> <p>In an undirected graph, betweenness centrality measures the percentage of all shortest paths that a node appears on, therefore measuring the likeliness that a node may act as a connector or 'intermediary'.</p> <p>Uses networkx.betweenness_centrality() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.betweenness_centrality.html#networkx.algorithms.centrality.betweenness_centrality</p> Inputs field name type description required default network_data network_data The network graph being queried. yes weighted_betweenness boolean Boolean to indicate whether to calculate weighted betweenness as well as unweighted betweenness. no False weight_column_name string The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1. no weight weight_meaning boolean How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations. no True Outputs field name type description required default network_result table A table showing the rank and raw score for betweenness centrality. yes centrality_network network_data Updated network data with betweenness ranking assigned as a node attribute. yes"},{"location":"info/operations/#kiara_info.operations.create.closeness_rank_list","title":"<code>create.closeness_rank_list</code>","text":"Documentation <p>Creates an ordered table with the rank and raw score for closeness centrality.</p> <p>In an undirected graph, closeness centrality measures the average shortest distance path between a node and all reachable nodes in the network.</p> <p>Uses networkx.closeness_centrality() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality</p> Inputs field name type description required default network_data network_data The network graph being queried. yes weighted_closeness boolean Boolean to indicate whether to calculate weighted closeness as well as unweighted closeness. no False weight_column_name string The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1. no weight_meaning boolean How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations. no True Outputs field name type description required default network_result table A table showing the rank and raw score for closeness centrality. yes centrality_network network_data Updated network data with closeness ranking assigned as a node attribute. yes"},{"location":"info/operations/#kiara_info.operations.create.cut_point_list","title":"<code>create.cut_point_list</code>","text":"Documentation <p>Create a list of nodes that are cut-points.</p> <p>Cut-points are any node in a network whose removal disconnects members of the network, creating one or more new distinct components.</p> <p>Uses networkx.articulation_points() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.articulation_points.html</p> Inputs field name type description required default network_data network_data The network graph being queried. yes Outputs field name type description required default network_result list A list of all nodes that are cut-points. yes centrality_network network_data Updated network data with eigenvector ranking assigned as a node attribute. yes"},{"location":"info/operations/#kiara_info.operations.create.degree_rank_list","title":"<code>create.degree_rank_list</code>","text":"Documentation <p>Creates an ordered table with the rank and raw score for degree centrality.</p> <p>In an undirected graph, degree centrality measures the number of independent connections each node has.</p> <p>Uses networkx degree. https://networkx.org/documentation/stable/reference/generated/networkx.classes.function.degree.html</p> Inputs field name type description required default network_data network_data The network graph being queried. yes weighted_degree boolean Boolean to indicate whether to calculate weighted degree or not. Conditions for calculation can be set in 'weight_column_name'. no True weight_column_name string The name of the column in the edge table containing data for the 'weight' or 'strength' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weighted degree is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1. no Outputs field name type description required default network_result table A table showing the rank and raw score for degree centrality. yes centrality_network network_data Updated network data with degree ranking assigned as a node attribute. yes"},{"location":"info/operations/#kiara_info.operations.create.eigenvector_rank_list","title":"<code>create.eigenvector_rank_list</code>","text":"Documentation <p>Creates an ordered table with the rank and raw score for betweenness centrality.</p> <p>In an undirected graph, eigenvector centrality measures the extent to which a node is connected to other nodes of importance or influence.</p> <p>Uses networkx.eigenvector_centrality() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html#networkx.algorithms.centrality.eigenvector_centrality</p> Inputs field name type description required default network_data network_data The network graph being queried. yes iterations integer -- n/a -- no 1000 weighted_eigenvector boolean Boolean to indicate whether to calculate weighted eigenvector as well as unweighted eigenvector. no False weight_column_name string The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1. no weight_meaning boolean How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations. no True Outputs field name type description required default network_result table A table showing the rank and raw score for eigenvector centrality. yes centrality_network network_data Updated network data with eigenvector ranking assigned as a node attribute. yes"},{"location":"info/operations/#kiara_info.operations.get.network_info","title":"<code>get.network_info</code>","text":"Documentation <p>Return basic information for the newtork graph created, including number of nodes and edges.</p> <p>Needs to specify if graph is directed or undirected, but will default to undirected.</p> Inputs field name type description required default network_data network_data The network graph being queried. yes graph_type string The graph type: directed or undirected no undirected Outputs field name type description required default network_result string Information about the network graph. yes"},{"location":"info/operations/#kiara_info.operations.onboard.gml_file","title":"<code>onboard.gml_file</code>","text":"Documentation <p>This is a preliminary module for onboarding network data from gml files. It will likely be replaced by more generic onboarding modules when those are ready.</p> <p>Based on networkX deserialise GML file method: https://networkx.org/documentation/stable/reference/readwrite/generated/networkx.readwrite.gml.read_gml.html#networkx.readwrite.gml.read_gml</p> Inputs field name type description required default path string The path to the local file. yes label string The node attribute that holds the 'label' information. Set this input to 'id' when there is no 'label' attribute in gml file. no label Outputs field name type description required default network_data network_data The network/graph data. yes"},{"location":"info/operations/#kiara_info.operations.playground.get_lineage_data","title":"<code>playground.get_lineage_data</code>","text":"Documentation <p>Get lineage data to display in visualization.</p> Inputs field name type description required default table table The table for which we need lineage data. yes Outputs field name type description required default lineage_dict dict The dict containing lineage data. yes"},{"location":"info/operations/#kiara_info.operations.playground.tm_dash.add_column","title":"<code>playground.tm_dash.add_column</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default table_input table The table to which we need to append a column. yes array_input array The array that needs to be appended as a column. yes Outputs field name type description required default preprocessed_tokens table The table with the additional column. yes"},{"location":"info/operations/#kiara_info.operations.playground.tm_dash.file_name_metadata","title":"<code>playground.tm_dash.file_name_metadata</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default table_input table The corpus for which we want to extract metadata from file names. yes column_name string The column containing metadata. In order to work, file names need to comply with LCCN pattern '/sn86069873/1900-01-05/' containing publication reference and date. yes Outputs field name type description required default table_output table Augmented table containing extracted metadata. yes publications_ref list List of unique publications refs in table. yes"},{"location":"info/operations/#kiara_info.operations.playground.tm_dash.map_column","title":"<code>playground.tm_dash.map_column</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default table_input table The table that we need to augment by mapping column values (for example an id with a name) in a new column. yes column_name string The column that needs mapping. yes mapping_keys list list containing 2 lists: 1st list contains values to replace, and the second the ones they should be replaced with. yes output_col_name string name of the newly created column yes Outputs field name type description required default table_output table Augmented table containing new column with mapped values. yes"},{"location":"info/operations/#kiara_info.operations.playground.tm_dash.table_sample","title":"<code>playground.tm_dash.table_sample</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default table_input table The table for which we need to create a sample, in order to test the results on a small portion of a table. yes Outputs field name type description required default table_sample table Random sample of 15 rows for the input table. yes"},{"location":"info/operations/#kiara_info.operations.playground.tm_dash.viz_data_query","title":"<code>playground.tm_dash.viz_data_query</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default query_type string The wished data periodicity to display on visualization. yes column string The column that contains publication names or ref/id. yes Outputs field name type description required default query string The query to pass to the sql query module. yes"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara_plugin<ul> <li>playground<ul> <li>data_types</li> <li>models</li> <li>modules<ul> <li>caitlin<ul> <li>cutpoints_module</li> <li>network_info_module</li> </ul> </li> <li>lena<ul> <li>centrality_measures_module</li> <li>example_module</li> <li>modularity</li> <li>onboarding</li> </ul> </li> <li>mariella<ul> <li>tm_dash</li> <li>viz_display</li> </ul> </li> </ul> </li> <li>my_kiara_module</li> <li>pipelines</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara_plugin/playground/__init__/","title":"playground","text":"<p>Top-level package for kiara_plugin.playground.</p>"},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': __author__, 'email': __email__}], 'description': 'Kiara modules for: playground', 'references': {'source_repo': {'desc': 'The module package git repository.', 'url': 'https://github.com/DHARPA-Project/kiara_plugin.playground'}, 'documentation': {'desc': 'The url for the module package documentation.', 'url': 'https://DHARPA-Project.github.io/kiara_plugin.playground/'}}, 'tags': ['playground'], 'labels': {'package': 'kiara_plugin.playground'}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground.find_modules","title":"<code>find_modules: KiaraEntryPointItem = (find_kiara_modules_under, 'kiara_plugin.playground.modules')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara_plugin.playground.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground.find_data_types","title":"<code>find_data_types: KiaraEntryPointItem = (find_data_types_under, 'kiara_plugin.playground.data_types')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground.find_pipelines","title":"<code>find_pipelines: KiaraEntryPointItem = (find_pipeline_base_path_for_module, 'kiara_plugin.playground.pipelines', KIARA_METADATA)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/__init__/#kiara_plugin.playground.get_version","title":"<code>get_version()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/__init__.py</code> <pre><code>def get_version():\n    from pkg_resources import DistributionNotFound, get_distribution\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = get_distribution(dist_name).version\n    except DistributionNotFound:\n\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except (Exception):\n            pass\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara_plugin/playground/data_types/","title":"data_types","text":"<p>This module contains the value type classes that are used in the <code>kiara_plugin.playground</code> package.</p>"},{"location":"reference/kiara_plugin/playground/models/","title":"models","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.playground</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of kiara.metadata.MetadataModel. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara_plugin/playground/my_kiara_module/","title":"my_kiara_module","text":""},{"location":"reference/kiara_plugin/playground/my_kiara_module/#kiara_plugin.playground.my_kiara_module-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/my_kiara_module/#kiara_plugin.playground.my_kiara_module.TutorialModule","title":"<code>TutorialModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/my_kiara_module.py</code> <pre><code>class TutorialModule(KiaraModule):\n\n    def create_inputs_schema(self):\n        return {\n            \"table_input\": {\n                \"type\": \"table\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"table_output\": {\n                \"type\": \"table\"\n            }\n        }\n\n    def process(self, inputs, outputs) -&gt; None:\n        pass\n</code></pre>"},{"location":"reference/kiara_plugin/playground/my_kiara_module/#kiara_plugin.playground.my_kiara_module.TutorialModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/my_kiara_module/#kiara_plugin.playground.my_kiara_module.TutorialModule.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/my_kiara_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"table_input\": {\n            \"type\": \"table\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/my_kiara_module/#kiara_plugin.playground.my_kiara_module.TutorialModule.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/my_kiara_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"table_output\": {\n            \"type\": \"table\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/my_kiara_module/#kiara_plugin.playground.my_kiara_module.TutorialModule.process","title":"<code>process(inputs, outputs) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/my_kiara_module.py</code> <pre><code>def process(self, inputs, outputs) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/__init__/","title":"caitlin","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/","title":"cutpoints_module","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Caitlin Burge', 'email': 'caitlin.burge@uni.lu'}], 'description': 'Kiara modules for: network_analysis'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module.CutPointsList","title":"<code>CutPointsList</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Create a list of nodes that are cut-points. Cut-points are any node in a network whose removal disconnects members of the network, creating one or more new distinct components.</p> <p>Uses networkx.articulation_points() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.articulation_points.html</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/cutpoints_module.py</code> <pre><code>class CutPointsList(KiaraModule):\n\"\"\"Create a list of nodes that are cut-points.\n    Cut-points are any node in a network whose removal disconnects members of the network, creating one or more new distinct components.\n\n    Uses networkx.articulation_points()\n    https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.articulation_points.html\"\"\"\n\n    _module_type_name = 'create.cut_point_list'\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_result\": {\n                \"type\": \"list\",\n                \"doc\" : \"A list of all nodes that are cut-points.\"\n            },\n            \"centrality_network\": {\n                \"type\": \"network_data\",\n                \"doc\": \"Updated network data with eigenvector ranking assigned as a node attribute.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n\n        network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                                # convenience methods it can give you:\n                                                # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n        G = network_data.as_networkx_graph(nx.Graph)  # you can also use nx.DiGraph or other types\n\n        cutpoints = list(nx.articulation_points(G))\n\n        cut_dict = {}\n        for node in G:\n            if node in cutpoints:\n                cut_dict[node] = 'Yes'\n            else:\n                cut_dict[node] = 'No'\n\n        nx.set_node_attributes(G, cut_dict, 'Cut Point')\n\n        attribute_network = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(network_result=cutpoints, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module.CutPointsList-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module.CutPointsList.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/cutpoints_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module.CutPointsList.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/cutpoints_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_result\": {\n            \"type\": \"list\",\n            \"doc\" : \"A list of all nodes that are cut-points.\"\n        },\n        \"centrality_network\": {\n            \"type\": \"network_data\",\n            \"doc\": \"Updated network data with eigenvector ranking assigned as a node attribute.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/cutpoints_module/#kiara_plugin.playground.modules.caitlin.cutpoints_module.CutPointsList.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/cutpoints_module.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n\n    network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                            # convenience methods it can give you:\n                                            # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n    G = network_data.as_networkx_graph(nx.Graph)  # you can also use nx.DiGraph or other types\n\n    cutpoints = list(nx.articulation_points(G))\n\n    cut_dict = {}\n    for node in G:\n        if node in cutpoints:\n            cut_dict[node] = 'Yes'\n        else:\n            cut_dict[node] = 'No'\n\n    nx.set_node_attributes(G, cut_dict, 'Cut Point')\n\n    attribute_network = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(network_result=cutpoints, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/","title":"network_info_module","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Caitlin Burge', 'email': 'caitlin.burge@uni.lu'}], 'description': 'Kiara modules for: network_analysis'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module.NetworkInfo","title":"<code>NetworkInfo</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Return basic information for the newtork graph created, including number of nodes and edges.</p> <p>Needs to specify if graph is directed or undirected, but will default to undirected.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/network_info_module.py</code> <pre><code>class NetworkInfo(KiaraModule):\n\"\"\"Return basic information for the newtork graph created, including number of nodes and edges.\n\n    Needs to specify if graph is directed or undirected, but will default to undirected.\"\"\"\n\n    _module_type_name = 'get.network_info'\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\"\n            },\n            \"graph_type\": {\n                \"type\": \"string\",\n                \"doc\": \"The graph type: directed or undirected\",\n                \"default\": \"undirected\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_result\": {\n                \"type\": \"string\",\n                \"doc\" : \"Information about the network graph.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n        graph = inputs.get_value_data('graph_type')\n\n        network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                                # convenience methods it can give you:\n                                                # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n        if graph == 'directed':\n            G = network_data.as_networkx_graph(nx.DiGraph)\n        else:\n            G = network_data.as_networkx_graph(nx.Graph)\n\n        if nx.is_directed(G) == True:\n                info = str(\n                'Graph Type: Directed \\n' +\n                'Number of Nodes: ' + str(nx.number_of_nodes(G)) + '\\n'\n                'Number of Edges: ' + str(nx.number_of_edges(G)) + '\\n'\n                'Graph Density Score: ' + str(nx.density(G)) + '\\n'\n                'Number of Connected Components: ' + str(nx.number_connected_components(G)) + '\\n'\n                'Number of nodes in Largest Component: ' + str((G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])).number_of_nodes()) + '\\n'\n                'Network Diameter of Largest Component: ' + str(nx.diameter(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0]))) + '\\n'\n                'Average Path Length of Largest Component: ' + str(nx.average_shortest_path_length(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0]))) + '\\n'\n                )\n        else:\n        \tinfo = str(\n        \t'Graph Type: Undirected \\n' +\n        \t'Number of Nodes: ' + str(nx.number_of_nodes(G)) + '\\n'\n        \t'Number of Edges: ' + str(nx.number_of_edges(G)) + '\\n'\n            'Graph Density Score: ' + str(nx.density(G)) + '\\n'\n            'Number of Connected Components: ' + str(nx.number_connected_components(G)) + '\\n'\n            'Number of nodes in Largest Component: ' + str((G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])).number_of_nodes()) + '\\n'\n            'Network Diameter of Largest Component : ' + str(nx.diameter(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0]))) + '\\n'\n            'Average Path Length of Largest Component: ' + str(nx.average_shortest_path_length(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])))\n                )\n\n        outputs.set_value('network_result', info)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module.NetworkInfo-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module.NetworkInfo.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/network_info_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\"\n        },\n        \"graph_type\": {\n            \"type\": \"string\",\n            \"doc\": \"The graph type: directed or undirected\",\n            \"default\": \"undirected\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module.NetworkInfo.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/network_info_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_result\": {\n            \"type\": \"string\",\n            \"doc\" : \"Information about the network graph.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/caitlin/network_info_module/#kiara_plugin.playground.modules.caitlin.network_info_module.NetworkInfo.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/caitlin/network_info_module.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n    graph = inputs.get_value_data('graph_type')\n\n    network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                            # convenience methods it can give you:\n                                            # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n    if graph == 'directed':\n        G = network_data.as_networkx_graph(nx.DiGraph)\n    else:\n        G = network_data.as_networkx_graph(nx.Graph)\n\n    if nx.is_directed(G) == True:\n            info = str(\n            'Graph Type: Directed \\n' +\n            'Number of Nodes: ' + str(nx.number_of_nodes(G)) + '\\n'\n            'Number of Edges: ' + str(nx.number_of_edges(G)) + '\\n'\n            'Graph Density Score: ' + str(nx.density(G)) + '\\n'\n            'Number of Connected Components: ' + str(nx.number_connected_components(G)) + '\\n'\n            'Number of nodes in Largest Component: ' + str((G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])).number_of_nodes()) + '\\n'\n            'Network Diameter of Largest Component: ' + str(nx.diameter(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0]))) + '\\n'\n            'Average Path Length of Largest Component: ' + str(nx.average_shortest_path_length(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0]))) + '\\n'\n            )\n    else:\n    \tinfo = str(\n    \t'Graph Type: Undirected \\n' +\n    \t'Number of Nodes: ' + str(nx.number_of_nodes(G)) + '\\n'\n    \t'Number of Edges: ' + str(nx.number_of_edges(G)) + '\\n'\n        'Graph Density Score: ' + str(nx.density(G)) + '\\n'\n        'Number of Connected Components: ' + str(nx.number_connected_components(G)) + '\\n'\n        'Number of nodes in Largest Component: ' + str((G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])).number_of_nodes()) + '\\n'\n        'Network Diameter of Largest Component : ' + str(nx.diameter(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0]))) + '\\n'\n        'Average Path Length of Largest Component: ' + str(nx.average_shortest_path_length(G.subgraph(sorted(nx.connected_components(G), key=len, reverse=True)[0])))\n            )\n\n    outputs.set_value('network_result', info)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/__init__/","title":"lena","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/","title":"centrality_measures_module","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Caitlin Burge', 'email': 'caitlin.burge@uni.lu'}], 'description': 'Kiara modules for: network_analysis'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Degree_Ranking","title":"<code>Degree_Ranking</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Creates an ordered table with the rank and raw score for degree centrality. In an undirected graph, degree centrality measures the number of independent connections each node has.</p> <p>Uses networkx degree. https://networkx.org/documentation/stable/reference/generated/networkx.classes.function.degree.html</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>class Degree_Ranking(KiaraModule):\n\"\"\"Creates an ordered table with the rank and raw score for degree centrality.\n    In an undirected graph, degree centrality measures the number of independent connections each node has.\n\n    Uses networkx degree.\n    https://networkx.org/documentation/stable/reference/generated/networkx.classes.function.degree.html\"\"\"\n\n    _module_type_name = 'create.degree_rank_list'\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\"\n            },\n            \"weighted_degree\":{\n                \"type\": \"boolean\",\n                \"default\": True,\n                \"doc\": \"Boolean to indicate whether to calculate weighted degree or not. Conditions for calculation can be set in 'weight_column_name'.\"\n            },\n            \"weight_column_name\": {\n                \"type\" : \"string\",\n                \"default\": '',\n                \"doc\": \"The name of the column in the edge table containing data for the 'weight' or 'strength' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weighted degree is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\"\n            }   \n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_result\": {\n                \"type\": \"table\",\n                \"doc\" : \"A table showing the rank and raw score for degree centrality.\"\n            },\n            \"centrality_network\": {\n                \"type\": \"network_data\",\n                \"doc\": \"Updated network data with degree ranking assigned as a node attribute.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n        wd = inputs.get_value_data('weighted_degree')\n        weight_name = inputs.get_value_data('weight_column_name')\n\n        network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                                # convenience methods it can give you:\n                                                # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n        G = network_data.as_networkx_graph(nx.Graph)\n        G.remove_edges_from(list(nx.selfloop_edges(G)))\n\n        def result_func(list):\n            rank, count, previous, result = (0, 0, None, {})\n            for key, num in list:\n                count += 1\n                if num != previous:\n                    rank += count\n                    previous = num\n                    count = 0\n                result[key] = num, rank\n            return result\n\n        degree = {}\n        for node in G:\n            degree[node]= G.degree(node)\n        nx.set_node_attributes(G, degree, 'Degree Score')\n\n        sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(degree.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n        df= pd.DataFrame(sorted_dict, columns=['Rank','Node','Degree'])\n\n\n        if wd == True:\n            if weight_name == '':\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                weight_degree = {}\n                for node in graph:\n                    weight_degree[node]= graph.degree(node, weight='weight')\n                nx.set_node_attributes(G, weight_degree, 'Weighted Degree Score')\n\n                df2 = pd.DataFrame(list(weight_degree.items()), columns=['Node', 'Weighted Degree'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n            if weight_name != '':\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n                edge_weight = nx.get_edge_attributes(MG, weight_name)\n                for u,v,key in edge_weight:\n                    nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                weight_degree = {}\n                for node in graph:\n                    weight_degree[node]= graph.degree(node, weight='weight')\n                nx.set_node_attributes(G, weight_degree, 'Weighted Degree Score')\n\n                df2 = pd.DataFrame(list(weight_degree.items()), columns=['Node', 'Weighted Degree'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        attribute_network = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Degree_Ranking-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Degree_Ranking.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\"\n        },\n        \"weighted_degree\":{\n            \"type\": \"boolean\",\n            \"default\": True,\n            \"doc\": \"Boolean to indicate whether to calculate weighted degree or not. Conditions for calculation can be set in 'weight_column_name'.\"\n        },\n        \"weight_column_name\": {\n            \"type\" : \"string\",\n            \"default\": '',\n            \"doc\": \"The name of the column in the edge table containing data for the 'weight' or 'strength' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weighted degree is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\"\n        }   \n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Degree_Ranking.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_result\": {\n            \"type\": \"table\",\n            \"doc\" : \"A table showing the rank and raw score for degree centrality.\"\n        },\n        \"centrality_network\": {\n            \"type\": \"network_data\",\n            \"doc\": \"Updated network data with degree ranking assigned as a node attribute.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Degree_Ranking.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n    wd = inputs.get_value_data('weighted_degree')\n    weight_name = inputs.get_value_data('weight_column_name')\n\n    network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                            # convenience methods it can give you:\n                                            # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n    G = network_data.as_networkx_graph(nx.Graph)\n    G.remove_edges_from(list(nx.selfloop_edges(G)))\n\n    def result_func(list):\n        rank, count, previous, result = (0, 0, None, {})\n        for key, num in list:\n            count += 1\n            if num != previous:\n                rank += count\n                previous = num\n                count = 0\n            result[key] = num, rank\n        return result\n\n    degree = {}\n    for node in G:\n        degree[node]= G.degree(node)\n    nx.set_node_attributes(G, degree, 'Degree Score')\n\n    sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(degree.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n    df= pd.DataFrame(sorted_dict, columns=['Rank','Node','Degree'])\n\n\n    if wd == True:\n        if weight_name == '':\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            weight_degree = {}\n            for node in graph:\n                weight_degree[node]= graph.degree(node, weight='weight')\n            nx.set_node_attributes(G, weight_degree, 'Weighted Degree Score')\n\n            df2 = pd.DataFrame(list(weight_degree.items()), columns=['Node', 'Weighted Degree'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        if weight_name != '':\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n            edge_weight = nx.get_edge_attributes(MG, weight_name)\n            for u,v,key in edge_weight:\n                nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            weight_degree = {}\n            for node in graph:\n                weight_degree[node]= graph.degree(node, weight='weight')\n            nx.set_node_attributes(G, weight_degree, 'Weighted Degree Score')\n\n            df2 = pd.DataFrame(list(weight_degree.items()), columns=['Node', 'Weighted Degree'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n    attribute_network = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Betweenness_Ranking","title":"<code>Betweenness_Ranking</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Creates an ordered table with the rank and raw score for betweenness centrality. In an undirected graph, betweenness centrality measures the percentage of all shortest paths that a node appears on, therefore measuring the likeliness that a node may act as a connector or 'intermediary'.</p> <p>Uses networkx.betweenness_centrality() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.betweenness_centrality.html#networkx.algorithms.centrality.betweenness_centrality</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>class Betweenness_Ranking(KiaraModule):\n\"\"\"Creates an ordered table with the rank and raw score for betweenness centrality.\n    In an undirected graph, betweenness centrality measures the percentage of all shortest paths that a node appears on, therefore measuring the likeliness that a node may act as a connector or 'intermediary'.\n\n    Uses networkx.betweenness_centrality()\n    https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.betweenness_centrality.html#networkx.algorithms.centrality.betweenness_centrality\"\"\"\n\n    _module_type_name = 'create.betweenness_rank_list'\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\",\n                \"optional\": False,\n            },\n            \"weighted_betweenness\":{\n                \"type\": \"boolean\",\n                \"default\": False,\n                \"doc\": \"Boolean to indicate whether to calculate weighted betweenness as well as unweighted betweenness.\",\n                \"optional\": True,\n            },\n            \"weight_column_name\": {\n                \"type\" : \"string\",\n                \"default\": 'weight',\n                \"doc\": \"The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\",\n                \"optional\": True,\n            },\n            \"weight_meaning\":{\n                \"type\": \"boolean\",\n                \"default\": True,\n                \"doc\": \"How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations.\",\n                \"optional\": True,\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_result\": {\n                \"type\": \"table\",\n                \"doc\" : \"A table showing the rank and raw score for betweenness centrality.\"\n            },\n            \"centrality_network\": {\n                \"type\": \"network_data\",\n                \"doc\": \"Updated network data with betweenness ranking assigned as a node attribute.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n        wb = inputs.get_value_data('weighted_betweenness')\n        weight_name = inputs.get_value_data('weight_column_name')\n        wm = inputs.get_value_data('weight_meaning')\n\n        network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                                # convenience methods it can give you:\n                                                # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n        G = network_data.as_networkx_graph(nx.Graph)\n        G.remove_edges_from(list(nx.selfloop_edges(G)))\n        G.remove_nodes_from(list(nx.isolates(G)))\n\n        def result_func(list):\n            rank, count, previous, result = (0, 0, None, {})\n            for key, num in list:\n                count += 1\n                if num != previous:\n                    rank += count\n                    previous = num\n                    count = 0\n                result[key] = num, rank\n            return result\n\n        between = nx.betweenness_centrality(G)\n        nx.set_node_attributes(G, between, 'Betweenness Score')\n        sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(between.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n        df= pd.DataFrame(sorted_dict)\n        df.columns = ['Rank', 'Node', 'Score']\n\n        if wb == True:\n            if weight_name is None:\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                if wm == True:\n                    for u,v,d in graph.edges(data=True):\n                        d['weight']=(1/d['weight'])\n\n                weight_betweenness = nx.betweenness_centrality(graph, weight='weight')\n                nx.set_node_attributes(G, weight_betweenness, 'Weighted Betweenness Score')\n\n                df2 = pd.DataFrame(list(weight_betweenness.items()), columns=['Node', 'Weighted Betweenness'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n            if weight_name is not None:\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n                edge_weight = nx.get_edge_attributes(MG, weight_name)\n                for u,v,key in edge_weight:\n                    nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                if wm == True:\n                    for u,v,d in graph.edges(data=True):\n                        d['weight']=(1/d['weight'])\n\n                weight_betweenness = nx.betweenness_centrality(graph, weight='weight')\n                nx.set_node_attributes(G, weight_betweenness, 'Weighted Betweenness Score')\n\n                df2 = pd.DataFrame(list(weight_betweenness.items()), columns=['Node', 'Weighted Betweenness'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        attribute_network = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Betweenness_Ranking-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Betweenness_Ranking.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\",\n            \"optional\": False,\n        },\n        \"weighted_betweenness\":{\n            \"type\": \"boolean\",\n            \"default\": False,\n            \"doc\": \"Boolean to indicate whether to calculate weighted betweenness as well as unweighted betweenness.\",\n            \"optional\": True,\n        },\n        \"weight_column_name\": {\n            \"type\" : \"string\",\n            \"default\": 'weight',\n            \"doc\": \"The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\",\n            \"optional\": True,\n        },\n        \"weight_meaning\":{\n            \"type\": \"boolean\",\n            \"default\": True,\n            \"doc\": \"How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations.\",\n            \"optional\": True,\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Betweenness_Ranking.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_result\": {\n            \"type\": \"table\",\n            \"doc\" : \"A table showing the rank and raw score for betweenness centrality.\"\n        },\n        \"centrality_network\": {\n            \"type\": \"network_data\",\n            \"doc\": \"Updated network data with betweenness ranking assigned as a node attribute.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Betweenness_Ranking.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n    wb = inputs.get_value_data('weighted_betweenness')\n    weight_name = inputs.get_value_data('weight_column_name')\n    wm = inputs.get_value_data('weight_meaning')\n\n    network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                            # convenience methods it can give you:\n                                            # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n    G = network_data.as_networkx_graph(nx.Graph)\n    G.remove_edges_from(list(nx.selfloop_edges(G)))\n    G.remove_nodes_from(list(nx.isolates(G)))\n\n    def result_func(list):\n        rank, count, previous, result = (0, 0, None, {})\n        for key, num in list:\n            count += 1\n            if num != previous:\n                rank += count\n                previous = num\n                count = 0\n            result[key] = num, rank\n        return result\n\n    between = nx.betweenness_centrality(G)\n    nx.set_node_attributes(G, between, 'Betweenness Score')\n    sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(between.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n    df= pd.DataFrame(sorted_dict)\n    df.columns = ['Rank', 'Node', 'Score']\n\n    if wb == True:\n        if weight_name is None:\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            if wm == True:\n                for u,v,d in graph.edges(data=True):\n                    d['weight']=(1/d['weight'])\n\n            weight_betweenness = nx.betweenness_centrality(graph, weight='weight')\n            nx.set_node_attributes(G, weight_betweenness, 'Weighted Betweenness Score')\n\n            df2 = pd.DataFrame(list(weight_betweenness.items()), columns=['Node', 'Weighted Betweenness'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        if weight_name is not None:\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n            edge_weight = nx.get_edge_attributes(MG, weight_name)\n            for u,v,key in edge_weight:\n                nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            if wm == True:\n                for u,v,d in graph.edges(data=True):\n                    d['weight']=(1/d['weight'])\n\n            weight_betweenness = nx.betweenness_centrality(graph, weight='weight')\n            nx.set_node_attributes(G, weight_betweenness, 'Weighted Betweenness Score')\n\n            df2 = pd.DataFrame(list(weight_betweenness.items()), columns=['Node', 'Weighted Betweenness'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n    attribute_network = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Eigenvector_Ranking","title":"<code>Eigenvector_Ranking</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Creates an ordered table with the rank and raw score for betweenness centrality. In an undirected graph, eigenvector centrality measures the extent to which a node is connected to other nodes of importance or influence.</p> <p>Uses networkx.eigenvector_centrality() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html#networkx.algorithms.centrality.eigenvector_centrality</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>class Eigenvector_Ranking(KiaraModule):\n\"\"\"Creates an ordered table with the rank and raw score for betweenness centrality.\n    In an undirected graph, eigenvector centrality measures the extent to which a node is connected to other nodes of importance or influence.\n\n    Uses networkx.eigenvector_centrality()\n    https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html#networkx.algorithms.centrality.eigenvector_centrality\"\"\"\n\n    _module_type_name = 'create.eigenvector_rank_list'\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\"\n            },\n            \"iterations\": {\n                \"type\" : \"integer\",\n                \"default\": 1000\n            },\n            \"weighted_eigenvector\":{\n                \"type\": \"boolean\",\n                \"default\": False,\n                \"doc\": \"Boolean to indicate whether to calculate weighted eigenvector as well as unweighted eigenvector.\"\n            },\n            \"weight_column_name\": {\n                \"type\" : \"string\",\n                \"default\": '',\n                \"doc\": \"The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\"\n            },\n            \"weight_meaning\":{\n                \"type\": \"boolean\",\n                \"default\": True,\n                \"doc\": \"How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_result\": {\n                \"type\": \"table\",\n                \"doc\" : \"A table showing the rank and raw score for eigenvector centrality.\"\n            },\n            \"centrality_network\": {\n                \"type\": \"network_data\",\n                \"doc\": \"Updated network data with eigenvector ranking assigned as a node attribute.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n        iterations = inputs.get_value_data(\"iterations\")\n        wd = inputs.get_value_data('weighted_eigenvector')\n        weight_name = inputs.get_value_data('weight_column_name')\n        wm = inputs.get_value_data('weight_meaning')\n\n        network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                                # convenience methods it can give you:\n                                                # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n        G = network_data.as_networkx_graph(nx.Graph)\n        G.remove_edges_from(list(nx.selfloop_edges(G)))\n\n        def result_func(list):\n            rank, count, previous, result = (0, 0, None, {})\n            for key, num in list:\n                count += 1\n                if num != previous:\n                    rank += count\n                    previous = num\n                    count = 0\n                result[key] = num, rank\n            return result\n\n        eigenvector = nx.eigenvector_centrality(G, max_iter=iterations)\n        nx.set_node_attributes(G, eigenvector, 'Eigenvector Score')\n        sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(eigenvector.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n        df= pd.DataFrame(sorted_dict)\n        df.columns = ['Rank', 'Node', 'Score']\n\n        if wd == True:\n            if weight_name == '':\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                if wm == False:\n                    for u,v,d in graph.edges(data=True):\n                        d['weight'] == 1/d['weight']\n\n                weight_eigenvector = nx.eigenvector_centrality(graph, weight='weight', max_iter=iterations)\n                nx.set_node_attributes(G, weight_eigenvector, 'Weighted Eigenvector Score')\n\n                df2 = pd.DataFrame(list(weight_eigenvector.items()), columns=['Node', 'Weighted Eigenvector'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n            if weight_name != '':\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n                edge_weight = nx.get_edge_attributes(MG, weight_name)\n                for u,v,key in edge_weight:\n                    nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                if wm == False:\n                    for u,v,d in graph.edges(data=True):\n                        d['weight'] == 1/d['weight']\n\n                weight_eigenvector = nx.eigenvector_centrality(graph, weight='weight', max_iter=iterations)\n                nx.set_node_attributes(G, weight_eigenvector, 'Weighted Eigenvector Score')\n\n                df2 = pd.DataFrame(list(weight_eigenvector.items()), columns=['Node', 'Weighted Eigenvector'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        attribute_network = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Eigenvector_Ranking-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Eigenvector_Ranking.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\"\n        },\n        \"iterations\": {\n            \"type\" : \"integer\",\n            \"default\": 1000\n        },\n        \"weighted_eigenvector\":{\n            \"type\": \"boolean\",\n            \"default\": False,\n            \"doc\": \"Boolean to indicate whether to calculate weighted eigenvector as well as unweighted eigenvector.\"\n        },\n        \"weight_column_name\": {\n            \"type\" : \"string\",\n            \"default\": '',\n            \"doc\": \"The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\"\n        },\n        \"weight_meaning\":{\n            \"type\": \"boolean\",\n            \"default\": True,\n            \"doc\": \"How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Eigenvector_Ranking.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_result\": {\n            \"type\": \"table\",\n            \"doc\" : \"A table showing the rank and raw score for eigenvector centrality.\"\n        },\n        \"centrality_network\": {\n            \"type\": \"network_data\",\n            \"doc\": \"Updated network data with eigenvector ranking assigned as a node attribute.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Eigenvector_Ranking.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n    iterations = inputs.get_value_data(\"iterations\")\n    wd = inputs.get_value_data('weighted_eigenvector')\n    weight_name = inputs.get_value_data('weight_column_name')\n    wm = inputs.get_value_data('weight_meaning')\n\n    network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                            # convenience methods it can give you:\n                                            # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n    G = network_data.as_networkx_graph(nx.Graph)\n    G.remove_edges_from(list(nx.selfloop_edges(G)))\n\n    def result_func(list):\n        rank, count, previous, result = (0, 0, None, {})\n        for key, num in list:\n            count += 1\n            if num != previous:\n                rank += count\n                previous = num\n                count = 0\n            result[key] = num, rank\n        return result\n\n    eigenvector = nx.eigenvector_centrality(G, max_iter=iterations)\n    nx.set_node_attributes(G, eigenvector, 'Eigenvector Score')\n    sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(eigenvector.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n    df= pd.DataFrame(sorted_dict)\n    df.columns = ['Rank', 'Node', 'Score']\n\n    if wd == True:\n        if weight_name == '':\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            if wm == False:\n                for u,v,d in graph.edges(data=True):\n                    d['weight'] == 1/d['weight']\n\n            weight_eigenvector = nx.eigenvector_centrality(graph, weight='weight', max_iter=iterations)\n            nx.set_node_attributes(G, weight_eigenvector, 'Weighted Eigenvector Score')\n\n            df2 = pd.DataFrame(list(weight_eigenvector.items()), columns=['Node', 'Weighted Eigenvector'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        if weight_name != '':\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n            edge_weight = nx.get_edge_attributes(MG, weight_name)\n            for u,v,key in edge_weight:\n                nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            if wm == False:\n                for u,v,d in graph.edges(data=True):\n                    d['weight'] == 1/d['weight']\n\n            weight_eigenvector = nx.eigenvector_centrality(graph, weight='weight', max_iter=iterations)\n            nx.set_node_attributes(G, weight_eigenvector, 'Weighted Eigenvector Score')\n\n            df2 = pd.DataFrame(list(weight_eigenvector.items()), columns=['Node', 'Weighted Eigenvector'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n    attribute_network = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Closeness_Ranking","title":"<code>Closeness_Ranking</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Creates an ordered table with the rank and raw score for closeness centrality. In an undirected graph, closeness centrality measures the average shortest distance path between a node and all reachable nodes in the network.</p> <p>Uses networkx.closeness_centrality() https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>class Closeness_Ranking(KiaraModule):\n\"\"\"Creates an ordered table with the rank and raw score for closeness centrality.\n    In an undirected graph, closeness centrality measures the average shortest distance path between a node and all reachable nodes in the network.\n\n    Uses networkx.closeness_centrality()\n    https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality\"\"\"\n\n    _module_type_name = 'create.closeness_rank_list'\n\n    def create_inputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network graph being queried.\"\n            },\n            \"weighted_closeness\":{\n                \"type\": \"boolean\",\n                \"default\": False,\n                \"doc\": \"Boolean to indicate whether to calculate weighted closeness as well as unweighted closeness.\"\n            },\n            \"weight_column_name\": {\n                \"type\" : \"string\",\n                \"default\": '',\n                \"doc\": \"The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\"\n            },\n            \"weight_meaning\":{\n                \"type\": \"boolean\",\n                \"default\": True,\n                \"doc\": \"How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"network_result\": {\n                \"type\": \"table\",\n                \"doc\" : \"A table showing the rank and raw score for closeness centrality.\"\n            },\n            \"centrality_network\": {\n                \"type\": \"network_data\",\n                \"doc\": \"Updated network data with closeness ranking assigned as a node attribute.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n        wd = inputs.get_value_data('weighted_closeness')\n        weight_name = inputs.get_value_data('weight_column_name')\n        wm = inputs.get_value_data('weight_meaning')\n\n        network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                                # convenience methods it can give you:\n                                                # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n        G = network_data.as_networkx_graph(nx.Graph)\n        G.remove_edges_from(list(nx.selfloop_edges(G)))\n\n        def result_func(list):\n            rank, count, previous, result = (0, 0, None, {})\n            for key, num in list:\n                count += 1\n                if num != previous:\n                    rank += count\n                    previous = num\n                    count = 0\n                result[key] = num, rank\n            return result\n\n        closeness = nx.closeness_centrality(G)\n        nx.set_node_attributes(G, closeness, 'Closeness Score')\n        sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(closeness.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n        df= pd.DataFrame(sorted_dict)\n        df.columns = ['Rank', 'Node', 'Score']\n\n        if wd == True:\n            if weight_name == '':\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                if wm == True:\n                    for u,v,d in graph.edges(data=True):\n                        d['weight'] == 1/d['weight']\n\n                weight_closeness = nx.closeness_centrality(graph, weight='weight')\n                nx.set_node_attributes(G, weight_closeness, 'Weighted Closeness Score')\n\n                df2 = pd.DataFrame(list(weight_closeness.items()), columns=['Node', 'Weighted Closeness'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n            if weight_name != '':\n                MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n                edge_weight = nx.get_edge_attributes(MG, weight_name)\n                for u,v,key in edge_weight:\n                    nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n                graph = nx.DiGraph()\n                for u,v,data in MG.edges(data=True):\n                    w = data['weight'] if 'weight' in data else 1\n                    if graph.has_edge(u,v):\n                        graph[u][v]['weight'] += w\n                    else:\n                        graph.add_edge(u, v, weight=w)\n\n                if wm == True:\n                    for u,v,d in graph.edges(data=True):\n                        d['weight'] == 1/d['weight']\n\n                weight_closeness = nx.closeness_centrality(graph, weight='weight')\n                nx.set_node_attributes(G, weight_closeness, 'Weighted Closeness Score')\n\n                df2 = pd.DataFrame(list(weight_closeness.items()), columns=['Node', 'Weighted Closeness'])\n                df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        attribute_network = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Closeness_Ranking-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Closeness_Ranking.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_inputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network graph being queried.\"\n        },\n        \"weighted_closeness\":{\n            \"type\": \"boolean\",\n            \"default\": False,\n            \"doc\": \"Boolean to indicate whether to calculate weighted closeness as well as unweighted closeness.\"\n        },\n        \"weight_column_name\": {\n            \"type\" : \"string\",\n            \"default\": '',\n            \"doc\": \"The name of the column in the edge table containing data for the 'weight' of an edge. If there is a column already named 'weight', this will be automatically selected. If otherwise left empty, weight is calculated by aggregrating parallel edges where edge weight is assigned a weight of 1.\"\n        },\n        \"weight_meaning\":{\n            \"type\": \"boolean\",\n            \"default\": True,\n            \"doc\": \"How the weights given should be interpreted. If 'True', weight will be defined positively as 'strength', and these edges will be prioritised in shortest path calculations. If 'False', weight will be defined negatively as 'cost' or 'distance', and these edges will be avoided in shortest path calculations.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Closeness_Ranking.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_result\": {\n            \"type\": \"table\",\n            \"doc\" : \"A table showing the rank and raw score for closeness centrality.\"\n        },\n        \"centrality_network\": {\n            \"type\": \"network_data\",\n            \"doc\": \"Updated network data with closeness ranking assigned as a node attribute.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/centrality_measures_module/#kiara_plugin.playground.modules.lena.centrality_measures_module.Closeness_Ranking.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/centrality_measures_module.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n    wd = inputs.get_value_data('weighted_closeness')\n    weight_name = inputs.get_value_data('weight_column_name')\n    wm = inputs.get_value_data('weight_meaning')\n\n    network_data: NetworkData = edges.data  # check the source for the NetworkData class to see what\n                                            # convenience methods it can give you:\n                                            # https://github.com/DHARPA-Project/kiara_plugin.network_analysis/blob/develop/src/kiara_plugin/network_analysis/models.py#L52\n\n    G = network_data.as_networkx_graph(nx.Graph)\n    G.remove_edges_from(list(nx.selfloop_edges(G)))\n\n    def result_func(list):\n        rank, count, previous, result = (0, 0, None, {})\n        for key, num in list:\n            count += 1\n            if num != previous:\n                rank += count\n                previous = num\n                count = 0\n            result[key] = num, rank\n        return result\n\n    closeness = nx.closeness_centrality(G)\n    nx.set_node_attributes(G, closeness, 'Closeness Score')\n    sorted_dict = [[item[1][1], item [0], item[1][0]] for item in sorted(result_func(sorted(closeness.items(), key=itemgetter(1), reverse =True)).items(), key=itemgetter(1), reverse =True)]\n\n    df= pd.DataFrame(sorted_dict)\n    df.columns = ['Rank', 'Node', 'Score']\n\n    if wd == True:\n        if weight_name == '':\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            if wm == True:\n                for u,v,d in graph.edges(data=True):\n                    d['weight'] == 1/d['weight']\n\n            weight_closeness = nx.closeness_centrality(graph, weight='weight')\n            nx.set_node_attributes(G, weight_closeness, 'Weighted Closeness Score')\n\n            df2 = pd.DataFrame(list(weight_closeness.items()), columns=['Node', 'Weighted Closeness'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n        if weight_name != '':\n            MG = network_data.as_networkx_graph(nx.MultiDiGraph)\n            edge_weight = nx.get_edge_attributes(MG, weight_name)\n            for u,v,key in edge_weight:\n                nx.set_edge_attributes(MG, edge_weight, 'weight')\n\n            graph = nx.DiGraph()\n            for u,v,data in MG.edges(data=True):\n                w = data['weight'] if 'weight' in data else 1\n                if graph.has_edge(u,v):\n                    graph[u][v]['weight'] += w\n                else:\n                    graph.add_edge(u, v, weight=w)\n\n            if wm == True:\n                for u,v,d in graph.edges(data=True):\n                    d['weight'] == 1/d['weight']\n\n            weight_closeness = nx.closeness_centrality(graph, weight='weight')\n            nx.set_node_attributes(G, weight_closeness, 'Weighted Closeness Score')\n\n            df2 = pd.DataFrame(list(weight_closeness.items()), columns=['Node', 'Weighted Closeness'])\n            df = df.merge(df2, how='left', on='Node').reset_index(drop=True)\n\n    attribute_network = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(network_result=df, centrality_network=attribute_network)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/","title":"example_module","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}]}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.FindLargestComponentsModuleConfig","title":"<code>FindLargestComponentsModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/example_module.py</code> <pre><code>class FindLargestComponentsModuleConfig(KiaraModuleConfig):\n\n    find_largest_component: bool = Field(\n        description=\"Find the largest component of a graph.\", default=True\n    )\n\n    number_of_components: bool = Field(\n        description=\"Count the number of components.\", default=True\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.FindLargestComponentsModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.FindLargestComponentsModuleConfig.find_largest_component","title":"<code>find_largest_component: bool = Field(description='Find the largest component of a graph.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.FindLargestComponentsModuleConfig.number_of_components","title":"<code>number_of_components: bool = Field(description='Count the number of components.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule","title":"<code>GraphComponentsModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Counts all graph components and creates new graph from largest component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/example_module.py</code> <pre><code>class GraphComponentsModule(KiaraModule):\n\"\"\"Counts all graph components and creates new graph from largest component.\"\"\"\n\n    _config_cls = FindLargestComponentsModuleConfig\n    _module_type_name = \"graph_components\"\n\n    def create_input_schema(\n        self,\n    ) -&gt; typing.Mapping[\n        str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]]\n    ]:\n\n        return {\"graph\": {\"type\": \"network_graph\", \"doc\": \"The network graph.\"}}\n\n    def create_output_schema(\n        self,\n    ) -&gt; typing.Mapping[\n        str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]]\n    ]:\n\n        result = {}\n        if self.get_config_value(\"find_largest_component\"):\n            result[\"largest_component\"] = {\n                \"type\": \"network_graph\",\n                \"doc\": \"A sub-graph of the largest component of the graph.\",\n            }\n\n        if self.get_config_value(\"number_of_components\"):\n            result[\"number_of_components\"] = {\n                \"type\": \"integer\",\n                \"doc\": \"The number of components in the graph.\",\n            }\n\n        return result\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        if self.get_config_value(\"find_largest_component\"):\n            input_graph: Graph = inputs.get_value_data(\"graph\")\n            print(f\"INPUT: {input_graph}\")\n            undir_graph = nx.to_undirected(input_graph)\n            undir_components = nx.connected_components(undir_graph)\n            lg_component = max(undir_components, key=len)\n            subgraph = input_graph.subgraph(lg_component)\n            print(f\"subgraph: {subgraph}\")\n\n            outputs.set_values(largest_component=subgraph)\n\n        if self.get_config_value(\"number_of_components\"):\n            input_graph = inputs.get_value_data(\"graph\")\n            undir_graph = nx.to_undirected(input_graph)\n            number_of_components = nx.number_connected_components(undir_graph)\n\n            outputs.set_values(number_of_components=number_of_components)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule._config_cls","title":"<code>_config_cls = FindLargestComponentsModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule.create_input_schema","title":"<code>create_input_schema() -&gt; typing.Mapping[str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]]]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/example_module.py</code> <pre><code>def create_input_schema(\n    self,\n) -&gt; typing.Mapping[\n    str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]]\n]:\n\n    return {\"graph\": {\"type\": \"network_graph\", \"doc\": \"The network graph.\"}}\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule.create_output_schema","title":"<code>create_output_schema() -&gt; typing.Mapping[str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]]]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/example_module.py</code> <pre><code>def create_output_schema(\n    self,\n) -&gt; typing.Mapping[\n    str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]]\n]:\n\n    result = {}\n    if self.get_config_value(\"find_largest_component\"):\n        result[\"largest_component\"] = {\n            \"type\": \"network_graph\",\n            \"doc\": \"A sub-graph of the largest component of the graph.\",\n        }\n\n    if self.get_config_value(\"number_of_components\"):\n        result[\"number_of_components\"] = {\n            \"type\": \"integer\",\n            \"doc\": \"The number of components in the graph.\",\n        }\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/example_module/#kiara_plugin.playground.modules.lena.example_module.GraphComponentsModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/example_module.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    if self.get_config_value(\"find_largest_component\"):\n        input_graph: Graph = inputs.get_value_data(\"graph\")\n        print(f\"INPUT: {input_graph}\")\n        undir_graph = nx.to_undirected(input_graph)\n        undir_components = nx.connected_components(undir_graph)\n        lg_component = max(undir_components, key=len)\n        subgraph = input_graph.subgraph(lg_component)\n        print(f\"subgraph: {subgraph}\")\n\n        outputs.set_values(largest_component=subgraph)\n\n    if self.get_config_value(\"number_of_components\"):\n        input_graph = inputs.get_value_data(\"graph\")\n        undir_graph = nx.to_undirected(input_graph)\n        number_of_components = nx.number_connected_components(undir_graph)\n\n        outputs.set_values(number_of_components=number_of_components)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/","title":"modularity","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}], 'description': 'Kiara modules for: network_analysis'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity.ModularityCommunity","title":"<code>ModularityCommunity</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Calculate modularity for each node and attach modularity group number to node list as attribute.</p> <p>This networkX based function uses Clauset-Newman-Moore greedy modularity maximization to find the community partition with the largest modularity.</p> <p>Modularity community is a density-based community detection method that investigates the structural composition of a network.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/modularity.py</code> <pre><code>class ModularityCommunity(KiaraModule):\n\"\"\"Calculate modularity for each node and attach modularity group number to node list as attribute.\n\n    This networkX based function uses Clauset-Newman-Moore greedy modularity maximization to find the community partition with the largest modularity.\n\n    Modularity community is a density-based community detection method that investigates the structural composition of a network.\n    \"\"\"\n\n    _module_type_name = 'compute.modularity_group'\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result = {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network data to analyze.\",\n                \"optional\": False,\n            },\n            \"number_of_communities\":{\n                \"type\": \"integer\",\n                \"doc\": \"Number of communities into which the network should be partitioned. This is a user defined number that can be above or below maximum modularity.\",\n                \"optional\": True,\n            }\n        }\n        return result\n\n    def create_outputs_schema(self):\n        return {\n            \"modularity_network\": {\n                \"type\": \"network_data\",\n                \"doc\": \"Updated network data with modularity group assigned as a node attribute.\"\n            },\n            \"maximum_modularity\":{\n                \"type\": \"integer\",\n                \"doc\": \"The number of communities at which maximum modularity is reached for this network. If the 'number_of_communities' is manually set, this number might deviate from the manually computed number.\",\n            }\n        }\n\n    def process(self, inputs, outputs):\n        edges = inputs.get_value_obj('network_data')\n\n        network_data: NetworkData = edges.data\n\n        G = network_data.as_networkx_graph(nx.Graph) #Other graph types will work as well and modularity group distribution can be different with different graph types. Maximum modularity can also be affected by edge weight, but this parameter is currently not set. If the graph consists on many unconnected components, then the modularity groups will mostly coincide with the components. It would then make sense to extract the largest connected component first and to run the modularity module on the largest component.\n\n        number_of_communities = inputs.get_value_data(\"number_of_communities\") #TODO: This integer must be in range [1, G.number_of_nodes()]; otherwise it will throw a networkX error.\n\n        if number_of_communities is None:\n            communities = community.greedy_modularity_communities(G)\n            maximum_modularity = len(communities)\n        else:\n            communities = community.greedy_modularity_communities(G, cutoff=number_of_communities, best_n=number_of_communities)\n            max_communities = community.greedy_modularity_communities(G)\n            maximum_modularity = len(max_communities)\n\n        modularity_dict = {} \n        for i,c in enumerate(communities): # Loop through the list of communities, keeping track of the number for the community\n            for name in c: # Loop through each node in a community\n                modularity_dict[name] = i # Create an entry in the dictionary for the node, where the value is which group it belongs to.\n\n        nx.set_node_attributes(G, modularity_dict, 'modularity_group')\n\n        attribute_network = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(modularity_network=attribute_network, maximum_modularity=maximum_modularity)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity.ModularityCommunity-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity.ModularityCommunity.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/modularity.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result = {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network data to analyze.\",\n            \"optional\": False,\n        },\n        \"number_of_communities\":{\n            \"type\": \"integer\",\n            \"doc\": \"Number of communities into which the network should be partitioned. This is a user defined number that can be above or below maximum modularity.\",\n            \"optional\": True,\n        }\n    }\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity.ModularityCommunity.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/modularity.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"modularity_network\": {\n            \"type\": \"network_data\",\n            \"doc\": \"Updated network data with modularity group assigned as a node attribute.\"\n        },\n        \"maximum_modularity\":{\n            \"type\": \"integer\",\n            \"doc\": \"The number of communities at which maximum modularity is reached for this network. If the 'number_of_communities' is manually set, this number might deviate from the manually computed number.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/modularity/#kiara_plugin.playground.modules.lena.modularity.ModularityCommunity.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/modularity.py</code> <pre><code>def process(self, inputs, outputs):\n    edges = inputs.get_value_obj('network_data')\n\n    network_data: NetworkData = edges.data\n\n    G = network_data.as_networkx_graph(nx.Graph) #Other graph types will work as well and modularity group distribution can be different with different graph types. Maximum modularity can also be affected by edge weight, but this parameter is currently not set. If the graph consists on many unconnected components, then the modularity groups will mostly coincide with the components. It would then make sense to extract the largest connected component first and to run the modularity module on the largest component.\n\n    number_of_communities = inputs.get_value_data(\"number_of_communities\") #TODO: This integer must be in range [1, G.number_of_nodes()]; otherwise it will throw a networkX error.\n\n    if number_of_communities is None:\n        communities = community.greedy_modularity_communities(G)\n        maximum_modularity = len(communities)\n    else:\n        communities = community.greedy_modularity_communities(G, cutoff=number_of_communities, best_n=number_of_communities)\n        max_communities = community.greedy_modularity_communities(G)\n        maximum_modularity = len(max_communities)\n\n    modularity_dict = {} \n    for i,c in enumerate(communities): # Loop through the list of communities, keeping track of the number for the community\n        for name in c: # Loop through each node in a community\n            modularity_dict[name] = i # Create an entry in the dictionary for the node, where the value is which group it belongs to.\n\n    nx.set_node_attributes(G, modularity_dict, 'modularity_group')\n\n    attribute_network = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(modularity_network=attribute_network, maximum_modularity=maximum_modularity)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/","title":"onboarding","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}], 'description': 'Kiara modules for: network_analysis'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding.GmlOnboarding","title":"<code>GmlOnboarding</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>This is a preliminary module for onboarding network data from gml files. It will likely be replaced by more generic onboarding modules when those are ready. Based on networkX deserialise GML file method: https://networkx.org/documentation/stable/reference/readwrite/generated/networkx.readwrite.gml.read_gml.html#networkx.readwrite.gml.read_gml</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/onboarding.py</code> <pre><code>class GmlOnboarding(KiaraModule):\n\"\"\"This is a preliminary module for onboarding network data from gml files. It will likely be replaced by more generic onboarding modules when those are ready.\n    Based on networkX deserialise GML file method: https://networkx.org/documentation/stable/reference/readwrite/generated/networkx.readwrite.gml.read_gml.html#networkx.readwrite.gml.read_gml\n    \"\"\"\n\n    _module_type_name = 'onboard.gml_file'\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result = {\n            #\"file\": {\n             #   \"type\": \"file\",\n              #  \"doc\": \"The source value (of type 'file').\",\n               # \"optional\": False,\n            #},\n            \"path\": {\n                \"type\": \"string\",\n                \"doc\": \"The path to the local file.\",\n                \"optional\": False,\n            },\n            \"label\":{\n                \"type\": \"string\",\n                \"doc\": \"The node attribute that holds the 'label' information. Set this input to 'id' when there is no 'label' attribute in gml file.\",\n                \"optional\": True,\n                \"default\": \"label\",\n            }\n        }\n        return result\n\n    def create_outputs_schema(self):\n        return {\n            \"network_data\": {\n                \"type\": \"network_data\",\n                \"doc\": \"The network/graph data.\"\n            }\n        }\n\n    def process(self, inputs, outputs):\n\n        input_file = inputs.get_value_data('path')\n        gml_file= input_file\n\n        #print(gml_file)\n        label = inputs.get_value_data('label')\n        #print(label)\n\n        if label is None:\n            G = nx.read_gml(gml_file)\n            #print(\"no label\")\n        else:\n            G = nx.read_gml(gml_file, label=label)\n            #print(\"with label\")\n\n        network_data = NetworkData.create_from_networkx_graph(G)\n\n        outputs.set_values(network_data=network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding.GmlOnboarding-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding.GmlOnboarding.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/onboarding.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result = {\n        #\"file\": {\n         #   \"type\": \"file\",\n          #  \"doc\": \"The source value (of type 'file').\",\n           # \"optional\": False,\n        #},\n        \"path\": {\n            \"type\": \"string\",\n            \"doc\": \"The path to the local file.\",\n            \"optional\": False,\n        },\n        \"label\":{\n            \"type\": \"string\",\n            \"doc\": \"The node attribute that holds the 'label' information. Set this input to 'id' when there is no 'label' attribute in gml file.\",\n            \"optional\": True,\n            \"default\": \"label\",\n        }\n    }\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding.GmlOnboarding.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/onboarding.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"network_data\": {\n            \"type\": \"network_data\",\n            \"doc\": \"The network/graph data.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/lena/onboarding/#kiara_plugin.playground.modules.lena.onboarding.GmlOnboarding.process","title":"<code>process(inputs, outputs)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/lena/onboarding.py</code> <pre><code>def process(self, inputs, outputs):\n\n    input_file = inputs.get_value_data('path')\n    gml_file= input_file\n\n    #print(gml_file)\n    label = inputs.get_value_data('label')\n    #print(label)\n\n    if label is None:\n        G = nx.read_gml(gml_file)\n        #print(\"no label\")\n    else:\n        G = nx.read_gml(gml_file, label=label)\n        #print(\"with label\")\n\n    network_data = NetworkData.create_from_networkx_graph(G)\n\n    outputs.set_values(network_data=network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/__init__/","title":"mariella","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/","title":"tm_dash","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.FileNameMetadata","title":"<code>FileNameMetadata</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>class FileNameMetadata(KiaraModule):\n\n    _module_type_name = \"playground.tm_dash.file_name_metadata\"\n\n    def create_inputs_schema(self):\n\n        return {\n            \"table_input\": {\n                \"type\": \"table\",\n                \"doc\": \"The corpus for which we want to extract metadata from file names.\"\n            },\n            \"column_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The column containing metadata. In order to work, file names need to comply with LCCN pattern '/sn86069873/1900-01-05/' containing publication reference and date.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"table_output\": {\n                \"type\": \"table\",\n                \"doc\": \"Augmented table containing extracted metadata.\"\n            },\n            \"publications_ref\": {\n                \"type\": \"list\",\n                \"doc\": \"List of unique publications refs in table.\"\n             },\n            # \"publications_count\": {\n            #     \"type\": \"list\",\n            #     \"doc\": \"Count of unique publications refs in table.\"\n            # }\n        }\n\n    def process(self, inputs, outputs) -&gt; None:\n\n        table_obj = inputs.get_value_obj(\"table_input\")\n        column_name = inputs.get_value_obj(\"column_name\").data\n\n        df = table_obj.data.to_pandas()\n\n         # get publication ref from file name\n        def get_ref(file):\n            ref_match = re.findall(r'(\\w+\\d+)_\\d{4}-\\d{2}-\\d{2}_',file)\n            if not ref_match:\n                raise KiaraProcessingException(f\"Can't process corpus, invalid format for file name: {file}\")\n            return ref_match[0]\n\n        # get date from file name\n        def get_date(file):\n            date_match = re.findall(r'_(\\d{4}-\\d{2}-\\d{2})_',file)\n            if not date_match:\n                raise KiaraProcessingException(f\"Can't process corpus, invalid format for file name: {file}\")\n            return date_match[0]\n\n        df['date'] = df['file_name'].apply(lambda x: get_date(x))\n\n        df['publication'] = df[column_name].apply(lambda x: get_ref(x))\n\n        df['date'] = pd.to_datetime(df['date'])\n        df = df.sort_values(by='date')\n\n        publications = df['publication'].unique().tolist()\n        # counts = [df['publication'].value_counts().index.to_list(),df['publication'].value_counts().to_list()]\n\n        outputs.set_value(\"table_output\", df)\n        # unique publications references useful at the next step to map publications references with publications names\n        outputs.set_value(\"publications_ref\", publications)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.FileNameMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.FileNameMetadata.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_inputs_schema(self):\n\n    return {\n        \"table_input\": {\n            \"type\": \"table\",\n            \"doc\": \"The corpus for which we want to extract metadata from file names.\"\n        },\n        \"column_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The column containing metadata. In order to work, file names need to comply with LCCN pattern '/sn86069873/1900-01-05/' containing publication reference and date.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.FileNameMetadata.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"table_output\": {\n            \"type\": \"table\",\n            \"doc\": \"Augmented table containing extracted metadata.\"\n        },\n        \"publications_ref\": {\n            \"type\": \"list\",\n            \"doc\": \"List of unique publications refs in table.\"\n         },\n        # \"publications_count\": {\n        #     \"type\": \"list\",\n        #     \"doc\": \"Count of unique publications refs in table.\"\n        # }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.FileNameMetadata.process","title":"<code>process(inputs, outputs) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def process(self, inputs, outputs) -&gt; None:\n\n    table_obj = inputs.get_value_obj(\"table_input\")\n    column_name = inputs.get_value_obj(\"column_name\").data\n\n    df = table_obj.data.to_pandas()\n\n     # get publication ref from file name\n    def get_ref(file):\n        ref_match = re.findall(r'(\\w+\\d+)_\\d{4}-\\d{2}-\\d{2}_',file)\n        if not ref_match:\n            raise KiaraProcessingException(f\"Can't process corpus, invalid format for file name: {file}\")\n        return ref_match[0]\n\n    # get date from file name\n    def get_date(file):\n        date_match = re.findall(r'_(\\d{4}-\\d{2}-\\d{2})_',file)\n        if not date_match:\n            raise KiaraProcessingException(f\"Can't process corpus, invalid format for file name: {file}\")\n        return date_match[0]\n\n    df['date'] = df['file_name'].apply(lambda x: get_date(x))\n\n    df['publication'] = df[column_name].apply(lambda x: get_ref(x))\n\n    df['date'] = pd.to_datetime(df['date'])\n    df = df.sort_values(by='date')\n\n    publications = df['publication'].unique().tolist()\n    # counts = [df['publication'].value_counts().index.to_list(),df['publication'].value_counts().to_list()]\n\n    outputs.set_value(\"table_output\", df)\n    # unique publications references useful at the next step to map publications references with publications names\n    outputs.set_value(\"publications_ref\", publications)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.MapColumn","title":"<code>MapColumn</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>class MapColumn(KiaraModule):\n\n    _module_type_name = \"playground.tm_dash.map_column\"\n\n    def create_inputs_schema(self):\n\n        return {\n            \"table_input\": {\n                \"type\": \"table\",\n                \"doc\": \"The table that we need to augment by mapping column values (for example an id with a name) in a new column.\"\n            },\n            \"column_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The column that needs mapping.\"\n            },\n            \"mapping_keys\": {\n                \"type\": \"list\",\n                \"doc\": \"list containing 2 lists: 1st list contains values to replace, and the second the ones they should be replaced with.\"\n            },\n            \"output_col_name\": {\n                \"type\": \"string\",\n                \"doc\": \"name of the newly created column\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"table_output\": {\n                \"type\": \"table\",\n                \"doc\": \"Augmented table containing new column with mapped values.\"\n            }\n        }\n\n    def process(self, inputs, outputs) -&gt; None:\n\n        table_obj = inputs.get_value_obj(\"table_input\")\n        column_name = inputs.get_value_obj(\"column_name\").data\n        mapping_keys = inputs.get_value_obj(\"mapping_keys\").data\n        output_col_name = inputs.get_value_obj(\"output_col_name\").data\n\n        df = table_obj.data.to_pandas()\n\n        df[output_col_name] = df[column_name].replace(to_replace=mapping_keys[0], value=mapping_keys[1])\n\n\n        outputs.set_value(\"table_output\", df)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.MapColumn-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.MapColumn.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_inputs_schema(self):\n\n    return {\n        \"table_input\": {\n            \"type\": \"table\",\n            \"doc\": \"The table that we need to augment by mapping column values (for example an id with a name) in a new column.\"\n        },\n        \"column_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The column that needs mapping.\"\n        },\n        \"mapping_keys\": {\n            \"type\": \"list\",\n            \"doc\": \"list containing 2 lists: 1st list contains values to replace, and the second the ones they should be replaced with.\"\n        },\n        \"output_col_name\": {\n            \"type\": \"string\",\n            \"doc\": \"name of the newly created column\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.MapColumn.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"table_output\": {\n            \"type\": \"table\",\n            \"doc\": \"Augmented table containing new column with mapped values.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.MapColumn.process","title":"<code>process(inputs, outputs) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def process(self, inputs, outputs) -&gt; None:\n\n    table_obj = inputs.get_value_obj(\"table_input\")\n    column_name = inputs.get_value_obj(\"column_name\").data\n    mapping_keys = inputs.get_value_obj(\"mapping_keys\").data\n    output_col_name = inputs.get_value_obj(\"output_col_name\").data\n\n    df = table_obj.data.to_pandas()\n\n    df[output_col_name] = df[column_name].replace(to_replace=mapping_keys[0], value=mapping_keys[1])\n\n\n    outputs.set_value(\"table_output\", df)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.TableSample","title":"<code>TableSample</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>class TableSample(KiaraModule):\n\n    _module_type_name = \"playground.tm_dash.table_sample\"\n\n    def create_inputs_schema(self):\n\n        return {\n            \"table_input\": {\n                \"type\": \"table\",\n                \"doc\": \"The table for which we need to create a sample, in order to test the results on a small portion of a table.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"table_sample\": {\n                \"type\": \"table\",\n                \"doc\": \"Random sample of 15 rows for the input table.\"\n            }\n        }\n\n    def process(self, inputs, outputs) -&gt; None:\n\n        table_obj = inputs.get_value_obj(\"table_input\")\n\n        df = table_obj.data.to_pandas() \n        df_sample = df.sample(n=15,axis=0)\n        if '__index_level_0__' in df_sample.columns:\n            df_sample = df_sample.drop(['__index_level_0__'],axis=1)\n        table_pa = pa.Table.from_pandas(df_sample)\n        outputs.set_value(\"table_sample\", table_pa)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.TableSample-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.TableSample.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_inputs_schema(self):\n\n    return {\n        \"table_input\": {\n            \"type\": \"table\",\n            \"doc\": \"The table for which we need to create a sample, in order to test the results on a small portion of a table.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.TableSample.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"table_sample\": {\n            \"type\": \"table\",\n            \"doc\": \"Random sample of 15 rows for the input table.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.TableSample.process","title":"<code>process(inputs, outputs) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def process(self, inputs, outputs) -&gt; None:\n\n    table_obj = inputs.get_value_obj(\"table_input\")\n\n    df = table_obj.data.to_pandas() \n    df_sample = df.sample(n=15,axis=0)\n    if '__index_level_0__' in df_sample.columns:\n        df_sample = df_sample.drop(['__index_level_0__'],axis=1)\n    table_pa = pa.Table.from_pandas(df_sample)\n    outputs.set_value(\"table_sample\", table_pa)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.AddColumn","title":"<code>AddColumn</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>class AddColumn(KiaraModule):\n\n    _module_type_name = \"playground.tm_dash.add_column\"\n\n    def create_inputs_schema(self):\n\n        return {\n            \"table_input\": {\n                \"type\": \"table\",\n                \"doc\": \"The table to which we need to append a column.\"\n            },\n            \"array_input\": {\n                \"type\": \"array\",\n                \"doc\": \"The array that needs to be appended as a column.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"preprocessed_tokens\": {\n                \"type\": \"table\",\n                \"doc\": \"The table with the additional column.\"\n            }\n        }\n\n    def process(self, inputs, outputs) -&gt; None:\n\n        table_obj = inputs.get_value_obj(\"table_input\")\n        array_obj = inputs.get_value_obj(\"array_input\")\n\n        df = table_obj.data.to_pandas()\n        col = array_obj.data.to_pylist()\n\n        df['preprocessed_tokens'] = col\n\n        outputs.set_value(\"preprocessed_tokens\", df)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.AddColumn-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.AddColumn.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_inputs_schema(self):\n\n    return {\n        \"table_input\": {\n            \"type\": \"table\",\n            \"doc\": \"The table to which we need to append a column.\"\n        },\n        \"array_input\": {\n            \"type\": \"array\",\n            \"doc\": \"The array that needs to be appended as a column.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.AddColumn.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"preprocessed_tokens\": {\n            \"type\": \"table\",\n            \"doc\": \"The table with the additional column.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.AddColumn.process","title":"<code>process(inputs, outputs) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def process(self, inputs, outputs) -&gt; None:\n\n    table_obj = inputs.get_value_obj(\"table_input\")\n    array_obj = inputs.get_value_obj(\"array_input\")\n\n    df = table_obj.data.to_pandas()\n    col = array_obj.data.to_pylist()\n\n    df['preprocessed_tokens'] = col\n\n    outputs.set_value(\"preprocessed_tokens\", df)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.VizDataQuery","title":"<code>VizDataQuery</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>class VizDataQuery(KiaraModule):\n\n    _module_type_name = \"playground.tm_dash.viz_data_query\"\n\n    def create_inputs_schema(self):\n\n        return {\n            \"query_type\": {\n                \"type\": \"string\",\n                \"doc\": \"The wished data periodicity to display on visualization.\"\n            },\n            \"column\": {\n                \"type\": \"string\",\n                \"doc\": \"The column that contains publication names or ref/id.\"\n            }\n        }\n\n    def create_outputs_schema(self):\n        return {\n            \"query\": {\n                \"type\": \"string\",\n                \"doc\": \"The query to pass to the sql query module.\"\n            }\n        }\n\n    def process(self, inputs, outputs) -&gt; None:\n\n        agg = inputs.get_value_obj(\"query_type\").data\n        col = inputs.get_value_obj(\"column\").data\n\n        if agg == 'month':\n            query = f\"SELECT strptime(concat(month, '/', year), '%m/%Y') as date, {col} as publication_name, count FROM (SELECT YEAR(date) as year, MONTH(date) as month, {col}, count(*) as count FROM data GROUP BY {col}, YEAR(date), MONTH(date))\"\n\n        elif agg == 'year':\n            query = f\"SELECT strptime(year, '%Y') as date, {col} as publication_name, count FROM (SELECT YEAR(date) as year, {col}, count(*) as count FROM data GROUP BY {col}, YEAR(date))\"\n\n        elif agg == 'day':\n            query = f\"SELECT strptime(concat('01/', month, '/', year), '%d/%m/%Y') as date, {col} as publication_name, count FROM (SELECT YEAR(date) as year, MONTH(date) as month, {col}, count(*) as count FROM data GROUP BY {col}, YEAR(date), MONTH(date), DAY(date))\"\n\n        outputs.set_value(\"query\", query)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.VizDataQuery-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.VizDataQuery.create_inputs_schema","title":"<code>create_inputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_inputs_schema(self):\n\n    return {\n        \"query_type\": {\n            \"type\": \"string\",\n            \"doc\": \"The wished data periodicity to display on visualization.\"\n        },\n        \"column\": {\n            \"type\": \"string\",\n            \"doc\": \"The column that contains publication names or ref/id.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.VizDataQuery.create_outputs_schema","title":"<code>create_outputs_schema()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def create_outputs_schema(self):\n    return {\n        \"query\": {\n            \"type\": \"string\",\n            \"doc\": \"The query to pass to the sql query module.\"\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/tm_dash/#kiara_plugin.playground.modules.mariella.tm_dash.VizDataQuery.process","title":"<code>process(inputs, outputs) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/tm_dash.py</code> <pre><code>def process(self, inputs, outputs) -&gt; None:\n\n    agg = inputs.get_value_obj(\"query_type\").data\n    col = inputs.get_value_obj(\"column\").data\n\n    if agg == 'month':\n        query = f\"SELECT strptime(concat(month, '/', year), '%m/%Y') as date, {col} as publication_name, count FROM (SELECT YEAR(date) as year, MONTH(date) as month, {col}, count(*) as count FROM data GROUP BY {col}, YEAR(date), MONTH(date))\"\n\n    elif agg == 'year':\n        query = f\"SELECT strptime(year, '%Y') as date, {col} as publication_name, count FROM (SELECT YEAR(date) as year, {col}, count(*) as count FROM data GROUP BY {col}, YEAR(date))\"\n\n    elif agg == 'day':\n        query = f\"SELECT strptime(concat('01/', month, '/', year), '%d/%m/%Y') as date, {col} as publication_name, count FROM (SELECT YEAR(date) as year, MONTH(date) as month, {col}, count(*) as count FROM data GROUP BY {col}, YEAR(date), MONTH(date), DAY(date))\"\n\n    outputs.set_value(\"query\", query)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/","title":"viz_display","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/#kiara_plugin.playground.modules.mariella.viz_display-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/#kiara_plugin.playground.modules.mariella.viz_display.GetLineageData","title":"<code>GetLineageData</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Get lineage data to display in visualization.</p> Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/viz_display.py</code> <pre><code>class GetLineageData(KiaraModule):\n\"\"\" Get lineage data to display in visualization.\n    \"\"\"\n\n    _module_type_name = \"playground.get_lineage_data\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n\n        inputs = {\n            \"table\": {\"type\": \"table\", \"doc\": \"The table for which we need lineage data.\"}\n        }\n\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        outputs = {\n            \"lineage_dict\": {\n                \"type\": \"dict\",\n                \"doc\": \"The dict containing lineage data.\",\n            }\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        table_obj = inputs.get_value_obj(\"table\")\n\n        kiara = KiaraAPI.instance()\n\n        graph = table_obj.lineage.module_graph\n        nodes = graph.nodes.data()\n        augmented_nodes = dict()\n\n\n        def get_info(node):\n            # all this is terribly inefficient\n            if node[1][\"node_type\"] == \"operation\":\n                result = kiara.retrieve_module_type_info(node[1][\"module_type\"]).dict()\n            elif node[1][\"node_type\"] == \"value\":\n                value_id = node[0][6:]\n                v = kiara.get_value(value_id)\n\n                render_result = kiara.render_value(value=v, target_format=\"string\").rendered\n\n                result = {\n                    \"preview\": render_result\n                }\n            return result\n\n        for idx, node in enumerate(nodes):\n            node_dict = {\n                \"id\": node[0],\n                \"desc\": node[1],\n                \"parentIds\": [pred for pred in graph.predecessors(node[0])],\n                \"info\": get_info(node)\n            }\n            augmented_nodes[idx] = node_dict\n\n        outputs.set_value(\"lineage_dict\", augmented_nodes)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/#kiara_plugin.playground.modules.mariella.viz_display.GetLineageData-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/#kiara_plugin.playground.modules.mariella.viz_display.GetLineageData.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/viz_display.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n\n    inputs = {\n        \"table\": {\"type\": \"table\", \"doc\": \"The table for which we need lineage data.\"}\n    }\n\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/#kiara_plugin.playground.modules.mariella.viz_display.GetLineageData.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/viz_display.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    outputs = {\n        \"lineage_dict\": {\n            \"type\": \"dict\",\n            \"doc\": \"The dict containing lineage data.\",\n        }\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara_plugin/playground/modules/mariella/viz_display/#kiara_plugin.playground.modules.mariella.viz_display.GetLineageData.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/kiara_plugin/playground/modules/mariella/viz_display.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    table_obj = inputs.get_value_obj(\"table\")\n\n    kiara = KiaraAPI.instance()\n\n    graph = table_obj.lineage.module_graph\n    nodes = graph.nodes.data()\n    augmented_nodes = dict()\n\n\n    def get_info(node):\n        # all this is terribly inefficient\n        if node[1][\"node_type\"] == \"operation\":\n            result = kiara.retrieve_module_type_info(node[1][\"module_type\"]).dict()\n        elif node[1][\"node_type\"] == \"value\":\n            value_id = node[0][6:]\n            v = kiara.get_value(value_id)\n\n            render_result = kiara.render_value(value=v, target_format=\"string\").rendered\n\n            result = {\n                \"preview\": render_result\n            }\n        return result\n\n    for idx, node in enumerate(nodes):\n        node_dict = {\n            \"id\": node[0],\n            \"desc\": node[1],\n            \"parentIds\": [pred for pred in graph.predecessors(node[0])],\n            \"info\": get_info(node)\n        }\n        augmented_nodes[idx] = node_dict\n\n    outputs.set_value(\"lineage_dict\", augmented_nodes)\n</code></pre>"},{"location":"reference/kiara_plugin/playground/pipelines/__init__/","title":"pipelines","text":"<p>Default (empty) module that is used as a base path for pipelines contained in this package.</p>"}]}